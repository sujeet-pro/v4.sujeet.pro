---
import Layout from "@/layout/layout.astro"
import { getSearchFacets } from "@/utils/search.utils"
import { SEARCH_SCHEMA } from "@/utils/search.types"
import { Icon } from "astro-icon/components"
import { getFilePath } from "@/utils/link.utils"

// Get facet options at build time (with counts, sorted by count)
const { categories, topics } = await getSearchFacets()

// Serialize data for client-side script
const searchSchemaJson = JSON.stringify(SEARCH_SCHEMA)
const searchIndexPath = getFilePath("search/index.json")
---

<Layout
  title="Search"
  description="Search for articles on Sujeet's blog"
  crumbs={null}
  pageType="default"
  layout="3col"
>
  <!-- Left sidebar: Filter panel -->
  <div slot="sidebar-left" id="filter-sidebar" class="filter-sidebar">
    <!-- Faceted Filters -->
    <div id="search-filters" class="search-filters">
      <!-- Categories (OR logic) -->
      {
        categories.length > 0 && (
          <div class="filter-group">
            <h3 class="filter-group-title">Categories</h3>
            <div class="filter-group-list" id="category-filters">
              {categories.map((cat) => (
                <label class="filter-chip" title={cat.title} data-filter-id={cat.id}>
                  <input type="checkbox" name="category" value={cat.id} class="filter-chip-input peer" />
                  <span class="tag peer-checked:badge-accent">
                    {cat.name}{" "}
                    <span class="filter-count text-muted" data-count-for={cat.id}>
                      ({cat.count})
                    </span>
                  </span>
                </label>
              ))}
            </div>
          </div>
        )
      }

      <!-- Topics (OR logic) -->
      {
        topics.length > 0 && (
          <div class="filter-group">
            <h3 class="filter-group-title">Topics</h3>
            <div class="filter-group-list" id="topic-filters">
              {topics.map((topic) => (
                <label class="filter-chip" title={topic.title} data-filter-id={topic.id}>
                  <input type="checkbox" name="topic" value={topic.id} class="filter-chip-input peer" />
                  <span class="tag peer-checked:badge-accent">
                    {topic.name}{" "}
                    <span class="filter-count text-muted" data-count-for={topic.id}>
                      ({topic.count})
                    </span>
                  </span>
                </label>
              ))}
            </div>
          </div>
        )
      }
    </div>

    <!-- Clear filters button -->
    <button id="clear-filters" class="clear-filters-btn is-hidden"> Clear all filters </button>
  </div>

  <!-- Main content: Search results -->
  <div class="search-page">
    <!-- Search Input -->
    <div class="search-input-wrapper">
      <input type="text" id="search-query" placeholder="Search..." class="search-input" autocomplete="off" />
      <p id="search-hint" class="search-hint">Press Enter to search</p>
    </div>

    <!-- Result count -->
    <p id="result-count" class="result-count is-hidden"></p>

    <!-- Results -->
    <ul id="search-results" class="article-list">
      <li id="search-placeholder" class="search-placeholder">
        <p class="text-muted">Loading articles...</p>
      </li>
    </ul>
  </div>

  <!-- Floating filter button (shown on mobile via JS) -->
  <button
    type="button"
    id="filter-mobile-btn"
    class="filter-mobile-btn"
    aria-label="Open filters"
    aria-expanded="false"
    aria-controls="filter-modal"
  >
    <Icon name="carbon:filter" class="icon-md" />
    <span id="active-filter-count" class="filter-badge is-hidden">0</span>
  </button>

  <!-- Filter Modal (populated via JS) -->
  <div id="filter-modal" class="filter-modal" role="dialog" aria-modal="true" aria-labelledby="filter-modal-title">
    <div class="filter-modal-backdrop"></div>
    <div class="filter-modal-content">
      <div class="filter-modal-header">
        <h2 id="filter-modal-title" class="filter-modal-title">Filters</h2>
        <button type="button" id="filter-modal-close" class="filter-modal-close" aria-label="Close filters">
          <Icon name="carbon:close" class="icon-md" />
        </button>
      </div>
      <div class="filter-modal-body">
        <!-- Filter content cloned here via JS -->
      </div>
      <div class="filter-modal-footer">
        <button id="modal-clear-filters" class="modal-clear-btn">Clear all</button>
        <button id="modal-apply-filters" class="modal-apply-btn">Apply</button>
      </div>
    </div>
  </div>

  <!-- Pass data to client via JSON script tags -->
  <script is:inline id="search-schema-data" type="application/json" set:html={searchSchemaJson} />
  <script is:inline id="search-index-path" type="application/json" set:html={JSON.stringify(searchIndexPath)} />
</Layout>

<script>
  import { create, load, search } from "@orama/orama"

  // Load shared constants from server-rendered JSON
  const searchSchema = JSON.parse(document.getElementById("search-schema-data")?.textContent ?? "{}")

  interface SearchParams {
    q: string
    categories: string[]
    topics: string[]
  }

  let db: Awaited<ReturnType<typeof create<typeof searchSchema>>> | null = null

  // Use DOM marker to track initialization (survives script re-execution)
  const INIT_MARKER = "data-search-initialized"

  // Get search index path from server-rendered data
  const searchIndexPath = JSON.parse(
    document.getElementById("search-index-path")?.textContent ?? '"/search/index.json"',
  )

  // Load search index
  async function loadIndex() {
    if (db) return
    try {
      const response = await fetch(searchIndexPath)
      const data = await response.json()
      db = create({ schema: searchSchema })
      load(db, data)
    } catch (e) {
      console.error("Failed to load search index:", e)
    }
  }

  // Parse URL params
  function getUrlParams(): SearchParams {
    const params = new URLSearchParams(window.location.search)
    return {
      q: params.get("q") || "",
      categories: params.get("categories")?.split(",").filter(Boolean) || [],
      topics: params.get("topics")?.split(",").filter(Boolean) || [],
    }
  }

  // Update URL and trigger search via replaceState
  function updateUrl(params: SearchParams) {
    const url = new URL(window.location.href)

    if (params.q) url.searchParams.set("q", params.q)
    else url.searchParams.delete("q")

    if (params.categories.length) url.searchParams.set("categories", params.categories.join(","))
    else url.searchParams.delete("categories")

    if (params.topics.length) url.searchParams.set("topics", params.topics.join(","))
    else url.searchParams.delete("topics")

    // Use replaceState to update URL without adding to history
    window.history.replaceState({}, "", url.toString())
    // Trigger search with new params
    handleUrlChange()
  }

  // Toggle a value in an array (add if not present, remove if present)
  function toggleArrayValue(arr: string[], value: string): string[] {
    const index = arr.indexOf(value)
    if (index === -1) {
      return [...arr, value]
    } else {
      return arr.filter((v) => v !== value)
    }
  }

  // Check if any filters (categories/topics) are active
  function hasFiltersActive(params: SearchParams) {
    return params.categories.length > 0 || params.topics.length > 0
  }

  // Sync UI with current URL params
  function syncUIWithParams(params: SearchParams) {
    const queryInput = document.getElementById("search-query") as HTMLInputElement
    const hintEl = document.getElementById("search-hint") as HTMLParagraphElement
    const clearBtn = document.getElementById("clear-filters") as HTMLButtonElement

    if (!queryInput) return

    queryInput.value = params.q

    // Sync category checkboxes
    document.querySelectorAll<HTMLInputElement>('#filter-sidebar input[name="category"]').forEach((cb) => {
      cb.checked = params.categories.includes(cb.value)
    })

    // Sync topic checkboxes
    document.querySelectorAll<HTMLInputElement>('#filter-sidebar input[name="topic"]').forEach((cb) => {
      cb.checked = params.topics.includes(cb.value)
    })

    // Show/hide hint based on query
    if (params.q) {
      hintEl?.classList.add("is-hidden")
    } else {
      hintEl?.classList.remove("is-hidden")
    }

    // Show clear button only when filters (not query) are active
    if (hasFiltersActive(params)) {
      clearBtn?.classList.remove("is-hidden")
    } else {
      clearBtn?.classList.add("is-hidden")
    }
  }

  // Render a single result item HTML
  function renderResultItem(hit: any): string {
    const doc = hit.document
    const href = doc.href || ""
    const title = doc.title || "Untitled"
    const description = doc.description || ""
    const categoryId = doc.category || ""
    const categoryName = doc.categoryName || ""
    const topicId = doc.topic || ""
    const topicName = doc.topicName || ""
    const minutesRead = doc.minutesRead || ""

    return `
      <li class="article-card">
        <h3 class="article-card-title">
          <a href="${href}" class="article-card-link">${title}</a>
        </h3>
        <div class="frontmatter article-card-frontmatter">
          <span class="frontmatter-item">
            ${categoryName ? `<button type="button" class="frontmatter-filter-btn" data-filter-type="category" data-filter-value="${categoryId}">${categoryName}</button>` : ""}
            ${topicName ? `<span class="frontmatter-separator">/</span><button type="button" class="frontmatter-filter-btn" data-filter-type="topic" data-filter-value="${topicId}">${topicName}</button>` : ""}
          </span>
          ${
            minutesRead
              ? `<span class="frontmatter-item">
            <svg xmlns="http://www.w3.org/2000/svg" class="frontmatter-icon" viewBox="0 0 32 32"><path fill="currentColor" d="M16 30a14 14 0 1 1 14-14a14 14 0 0 1-14 14m0-26a12 12 0 1 0 12 12A12 12 0 0 0 16 4"/><path fill="currentColor" d="M20.59 22L15 16.41V7h2v8.58l5 5.01z"/></svg>
            <span>${minutesRead}</span>
          </span>`
              : ""
          }
        </div>
        <p class="article-card-excerpt">${description}</p>
      </li>
    `
  }

  // Calculate facet counts from a set of hits
  function calculateFacetCounts(hits: any[]): { categories: Map<string, number>; topics: Map<string, number> } {
    const categories = new Map<string, number>()
    const topics = new Map<string, number>()

    for (const hit of hits) {
      const category = hit.document.category || ""
      const topic = hit.document.topic || ""

      if (category) {
        categories.set(category, (categories.get(category) || 0) + 1)
      }
      if (topic) {
        topics.set(topic, (topics.get(topic) || 0) + 1)
      }
    }

    return { categories, topics }
  }

  // Update sidebar facet counts
  function updateFacetCounts(counts: { categories: Map<string, number>; topics: Map<string, number> }) {
    // Update category counts
    document.querySelectorAll("#category-filters [data-count-for]").forEach((el) => {
      const id = el.getAttribute("data-count-for")
      if (id) {
        const count = counts.categories.get(id) || 0
        el.textContent = `(${count})`
        // Dim the label if count is 0
        const label = el.closest(".filter-chip")
        if (label) {
          label.classList.toggle("filter-chip--empty", count === 0)
        }
      }
    })

    // Update topic counts
    document.querySelectorAll("#topic-filters [data-count-for]").forEach((el) => {
      const id = el.getAttribute("data-count-for")
      if (id) {
        const count = counts.topics.get(id) || 0
        el.textContent = `(${count})`
        // Dim the label if count is 0
        const label = el.closest(".filter-chip")
        if (label) {
          label.classList.toggle("filter-chip--empty", count === 0)
        }
      }
    })
  }

  // Execute search
  async function executeSearch(params: SearchParams) {
    await loadIndex()
    if (!db) {
      console.error("Search index not loaded")
      return
    }

    const resultsEl = document.getElementById("search-results") as HTMLUListElement
    const countEl = document.getElementById("result-count") as HTMLParagraphElement

    if (!resultsEl) return

    // Step 1: Execute search query (empty term returns all documents)
    const results = await search(db, {
      term: params.q || "",
      limit: 1000,
    })

    // Step 2: Get query-filtered results (before category/topic filters)
    const queryFilteredHits = results.hits as any[]

    // Step 3: Apply category/topic filters on top of query results
    let finalHits = queryFilteredHits

    // Category filter (OR logic - match any selected category)
    if (params.categories.length > 0) {
      finalHits = finalHits.filter((hit) => {
        const category = hit.document.category || ""
        return params.categories.includes(category)
      })
    }

    // Topic filter (OR logic - match any selected topic)
    if (params.topics.length > 0) {
      finalHits = finalHits.filter((hit) => {
        const topic = hit.document.topic || ""
        return params.topics.includes(topic)
      })
    }

    // Step 4: Calculate facet counts from final results (current displayed set)
    const facetCounts = calculateFacetCounts(finalHits)
    updateFacetCounts(facetCounts)

    // Handle no results
    if (finalHits.length === 0) {
      resultsEl.innerHTML = `
        <li class="search-placeholder">
          <p class="text-muted">No matching articles found. Try different search terms or filters.</p>
        </li>
      `
      countEl?.classList.add("is-hidden")
      return
    }

    // Show result count
    if (countEl) {
      countEl.textContent = `${finalHits.length} article${finalHits.length === 1 ? "" : "s"} found`
      countEl.classList.remove("is-hidden")
    }

    // Render all results
    resultsEl.innerHTML = finalHits.map(renderResultItem).join("")
  }

  // Update filter count badge
  function updateFilterCountBadge(params: SearchParams) {
    const countEl = document.getElementById("active-filter-count")
    if (!countEl) return

    const count = params.categories.length + params.topics.length
    if (count > 0) {
      countEl.textContent = String(count)
      countEl.classList.remove("is-hidden")
    } else {
      countEl.classList.add("is-hidden")
    }
  }

  // Handle URL change (the single source of truth for search)
  async function handleUrlChange() {
    const params = getUrlParams()
    syncUIWithParams(params)
    updateFilterCountBadge(params)
    await executeSearch(params)
  }

  // Filter modal functions
  function initFilterModal() {
    const mobileBtn = document.getElementById("filter-mobile-btn")
    const modal = document.getElementById("filter-modal")
    const modalBody = modal?.querySelector(".filter-modal-body")
    const closeBtn = document.getElementById("filter-modal-close")
    const backdrop = modal?.querySelector(".filter-modal-backdrop")
    const modalClearBtn = document.getElementById("modal-clear-filters")
    const modalApplyBtn = document.getElementById("modal-apply-filters")
    const filterSidebar = document.getElementById("filter-sidebar")
    const searchFilters = document.getElementById("search-filters")

    if (!mobileBtn || !modal || !modalBody || !searchFilters) return

    // Show mobile button (JS is enabled)
    mobileBtn.classList.add("is-visible")

    function openModal() {
      if (!modal || !modalBody || !searchFilters) return

      // Clone filter content into modal
      const filtersClone = searchFilters.cloneNode(true) as HTMLElement
      filtersClone.id = "modal-filters"

      // Update input names in cloned content to avoid conflicts
      filtersClone.querySelectorAll('input[name="category"]').forEach((input) => {
        input.setAttribute("name", "category-modal")
      })
      filtersClone.querySelectorAll('input[name="topic"]').forEach((input) => {
        input.setAttribute("name", "topic-modal")
      })

      modalBody.innerHTML = ""
      modalBody.appendChild(filtersClone)

      // Sync checkbox state with current params
      const params = getUrlParams()
      filtersClone.querySelectorAll<HTMLInputElement>('input[name="category-modal"]').forEach((cb) => {
        cb.checked = params.categories.includes(cb.value)
      })
      filtersClone.querySelectorAll<HTMLInputElement>('input[name="topic-modal"]').forEach((cb) => {
        cb.checked = params.topics.includes(cb.value)
      })

      // Add event listeners to modal category checkboxes
      filtersClone.querySelectorAll<HTMLInputElement>('input[name="category-modal"]').forEach((cb) => {
        cb.addEventListener("change", () => {
          const params = getUrlParams()
          params.categories = toggleArrayValue(params.categories, cb.value)
          // Sync sidebar checkbox
          const sidebarCb = filterSidebar?.querySelector<HTMLInputElement>(
            `input[name="category"][value="${cb.value}"]`,
          )
          if (sidebarCb) sidebarCb.checked = cb.checked
          updateUrl(params)
        })
      })

      // Add event listeners to modal topic checkboxes
      filtersClone.querySelectorAll<HTMLInputElement>('input[name="topic-modal"]').forEach((cb) => {
        cb.addEventListener("change", () => {
          const params = getUrlParams()
          params.topics = toggleArrayValue(params.topics, cb.value)
          // Sync sidebar checkbox
          const sidebarCb = filterSidebar?.querySelector<HTMLInputElement>(`input[name="topic"][value="${cb.value}"]`)
          if (sidebarCb) sidebarCb.checked = cb.checked
          updateUrl(params)
        })
      })

      modal.classList.add("is-open")
      mobileBtn?.setAttribute("aria-expanded", "true")
      document.body.style.overflow = "hidden"
      closeBtn?.focus()
    }

    function closeModal() {
      if (!modal || !modalBody) return
      modal.classList.remove("is-open")
      mobileBtn?.setAttribute("aria-expanded", "false")
      document.body.style.overflow = ""
      modalBody.innerHTML = ""
      mobileBtn?.focus()
    }

    // Event listeners
    mobileBtn.addEventListener("click", openModal)
    closeBtn?.addEventListener("click", closeModal)
    backdrop?.addEventListener("click", closeModal)
    modalApplyBtn?.addEventListener("click", closeModal)

    modalClearBtn?.addEventListener("click", () => {
      const params = getUrlParams()
      // Clear only filters, keep query
      updateUrl({ q: params.q, categories: [], topics: [] })
      closeModal()
    })

    // Close on Escape
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && modal.classList.contains("is-open")) {
        closeModal()
      }
    })
  }

  // Main initialization function
  async function initSearchPage() {
    // Guard: only run on search page
    const queryInput = document.getElementById("search-query") as HTMLInputElement
    if (!queryInput) return

    // Guard: prevent double initialization using DOM marker
    if (queryInput.hasAttribute(INIT_MARKER)) return
    queryInput.setAttribute(INIT_MARKER, "true")

    const clearBtn = document.getElementById("clear-filters") as HTMLButtonElement
    const resultsEl = document.getElementById("search-results")
    const filterSidebar = document.getElementById("filter-sidebar")

    // Initialize filter modal
    initFilterModal()

    // Listen for URL changes (back/forward navigation)
    window.addEventListener("popstate", handleUrlChange)

    // Handle filter button clicks in search results (event delegation)
    resultsEl?.addEventListener("click", (e: Event) => {
      const target = e.target as HTMLElement
      if (!target) return

      const filterBtn = target.closest(".frontmatter-filter-btn") as HTMLButtonElement | null
      if (!filterBtn) return

      e.preventDefault()
      e.stopPropagation()

      const filterType = filterBtn.getAttribute("data-filter-type")
      const filterValue = filterBtn.getAttribute("data-filter-value")
      if (!filterType || !filterValue) return

      const params = getUrlParams()

      if (filterType === "category") {
        params.categories = toggleArrayValue(params.categories, filterValue)
      } else if (filterType === "topic") {
        params.topics = toggleArrayValue(params.topics, filterValue)
      }

      updateUrl(params)
    })

    // Handle sidebar filter changes (event delegation on sidebar)
    filterSidebar?.addEventListener("change", (e: Event) => {
      const target = e.target as HTMLInputElement
      if (!target || target.type !== "checkbox") return

      const filterName = target.name
      const filterValue = target.value
      const params = getUrlParams()

      if (filterName === "category") {
        params.categories = toggleArrayValue(params.categories, filterValue)
      } else if (filterName === "topic") {
        params.topics = toggleArrayValue(params.topics, filterValue)
      }

      updateUrl(params)
    })

    // Query input: update URL on Enter
    queryInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        const params = getUrlParams()
        params.q = queryInput.value.trim()
        updateUrl(params)
      }
    })

    // Clear all filters (keep query): reset filters only
    clearBtn?.addEventListener("click", () => {
      const params = getUrlParams()
      updateUrl({ q: params.q, categories: [], topics: [] })
    })

    // Focus input on load
    queryInput.focus()

    // Initial sync and search based on current URL
    await handleUrlChange()
  }

  // Initialize on DOMContentLoaded
  document.addEventListener("DOMContentLoaded", initSearchPage)

  // Re-initialize on Astro page navigation (for SPA)
  // DOM marker will be naturally reset when page content is replaced
  document.addEventListener("astro:page-load", initSearchPage)
</script>

<style>
  .search-input:focus {
    border-color: var(--color-accent);
  }

  .filter-group {
    min-width: 200px;
  }

  .search-placeholder {
    padding: 2rem 0;
  }

  /* Active filter chip styling */
  .filter-chip input:checked + .tag {
    background: var(--color-accent);
    color: var(--color-bg);
  }

  .filter-chip input:checked + .tag .text-muted-foreground {
    color: rgba(255, 255, 255, 0.8);
  }

  /* Empty filter chip (count is 0) */
  .filter-chip--empty {
    opacity: 0.4;
    pointer-events: none;
  }

  .filter-chip--empty .tag {
    cursor: not-allowed;
  }

  /* Floating filter button - hidden by default, shown via JS */
  .filter-mobile-btn {
    display: none;
    position: fixed;
    bottom: 1.5rem;
    right: 1.5rem;
    z-index: 40;
    padding: 0.875rem;
    background-color: var(--color-accent);
    color: white;
    border: none;
    border-radius: 9999px;
    box-shadow:
      0 4px 6px -1px rgb(0 0 0 / 0.1),
      0 2px 4px -2px rgb(0 0 0 / 0.1);
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .filter-mobile-btn:hover {
    transform: scale(1.05);
  }

  .filter-mobile-btn:focus {
    outline: 2px solid var(--color-accent);
    outline-offset: 2px;
  }

  /* Show button only when sidebar is hidden (JS enabled) */
  .filter-mobile-btn.is-visible {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  @media (min-width: 1200px) {
    .filter-mobile-btn.is-visible {
      display: none;
    }
  }

  /* Filter badge on floating button */
  .filter-badge {
    position: absolute;
    top: -0.25rem;
    right: -0.25rem;
    min-width: 1.25rem;
    height: 1.25rem;
    padding: 0 0.25rem;
    font-size: 0.75rem;
    font-weight: 600;
    line-height: 1.25rem;
    text-align: center;
    background-color: var(--color-text);
    color: var(--color-bg);
    border-radius: 9999px;
  }

  /* Filter modal styles */
  .filter-modal {
    display: none;
    position: fixed;
    inset: 0;
    z-index: 50;
  }

  .filter-modal.is-open {
    display: flex;
    align-items: flex-end;
    justify-content: center;
  }

  .filter-modal-backdrop {
    position: absolute;
    inset: 0;
    background-color: rgb(0 0 0 / 0.5);
  }

  .filter-modal-content {
    position: relative;
    width: 100%;
    max-width: 28rem;
    max-height: 70vh;
    margin: 0 1rem 1rem;
    background-color: var(--color-bg);
    border-radius: 1rem;
    box-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.25);
    display: flex;
    flex-direction: column;
    animation: filterSlideUp 0.2s ease-out;
  }

  @keyframes filterSlideUp {
    from {
      transform: translateY(1rem);
      opacity: 0;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }

  .filter-modal-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 1rem 1.25rem;
    border-bottom: 1px solid var(--color-border);
  }

  .filter-modal-close {
    padding: 0.5rem;
    border: none;
    background: transparent;
    color: var(--color-text-muted);
    border-radius: 0.5rem;
    cursor: pointer;
    transition: color 0.2s;
  }

  .filter-modal-close:hover {
    color: var(--color-text);
  }

  .filter-modal-close:focus {
    outline: 2px solid var(--color-accent);
    outline-offset: 2px;
  }

  .filter-modal-body {
    padding: 1rem 1.25rem;
    overflow-y: auto;
    flex: 1;
  }

  .filter-modal-footer {
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 1rem 1.25rem;
    border-top: 1px solid var(--color-border);
  }

  /* Filter buttons in search results */
  .frontmatter-filter-btn {
    background: none;
    border: none;
    padding: 0;
    font: inherit;
    color: var(--color-text-muted);
    cursor: pointer;
    transition: color 0.15s ease;
  }

  .frontmatter-filter-btn:hover {
    color: var(--color-accent);
    text-decoration: underline;
  }

  .frontmatter-filter-btn:focus {
    outline: 2px solid var(--color-accent);
    outline-offset: 2px;
    border-radius: 2px;
  }
</style>
