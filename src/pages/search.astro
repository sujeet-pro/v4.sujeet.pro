---
import Layout from "@/layout/layout.astro"
import { getSearchFacets } from "@/utils/search.utils"
import { SEARCH_SCHEMA } from "@/utils/search.types"
import { Icon } from "astro-icon/components"
import { getFilePath } from "@/utils/link.utils"

// Get facet options at build time (with counts, sorted by count)
const { categories, topics } = await getSearchFacets()

// Serialize data for client-side script
const searchSchemaJson = JSON.stringify(SEARCH_SCHEMA)
const searchIndexPath = getFilePath("search/index.json")
---

<Layout
  title="Search"
  description="Search for articles on Sujeet's blog"
  crumbs={null}
  pageType="default"
  layout="3col"
>
  <!-- Left sidebar: Filter panel -->
  <div slot="sidebar-left" id="filter-sidebar" class="filter-sidebar">
    <!-- Faceted Filters -->
    <div id="search-filters" class="search-filters">
      <!-- Categories (OR logic) -->
      {
        categories.length > 0 && (
          <div class="filter-group">
            <h3 class="filter-group-title">Categories</h3>
            <div class="filter-group-list" id="category-filters">
              {categories.map((cat) => (
                <label class="filter-chip" title={cat.title}>
                  <input type="checkbox" name="category" value={cat.id} class="filter-chip-input peer" />
                  <span class="tag peer-checked:badge-accent">
                    {cat.name} <span class="text-muted">({cat.count})</span>
                  </span>
                </label>
              ))}
            </div>
          </div>
        )
      }

      <!-- Topics (OR logic) -->
      {
        topics.length > 0 && (
          <div class="filter-group">
            <h3 class="filter-group-title">Topics</h3>
            <div class="filter-group-list" id="topic-filters">
              {topics.map((topic) => (
                <label class="filter-chip" title={topic.title}>
                  <input type="checkbox" name="topic" value={topic.id} class="filter-chip-input peer" />
                  <span class="tag peer-checked:badge-accent">
                    {topic.name} <span class="text-muted">({topic.count})</span>
                  </span>
                </label>
              ))}
            </div>
          </div>
        )
      }
    </div>

    <!-- Clear filters button -->
    <button id="clear-filters" class="clear-filters-btn is-hidden"> Clear all filters </button>
  </div>

  <!-- Main content: Search results -->
  <div class="search-page">
    <!-- Search Input -->
    <div class="search-input-wrapper">
      <input type="text" id="search-query" placeholder="Search..." class="search-input" autocomplete="off" />
      <p id="search-hint" class="search-hint">Press Enter to search</p>
    </div>

    <!-- Result count -->
    <p id="result-count" class="result-count is-hidden"></p>

    <!-- Results -->
    <ul id="search-results" class="content-list">
      <li id="search-placeholder" class="content-item">
        <p class="text-muted">Enter a search term or select filters to find content.</p>
      </li>
    </ul>
  </div>

  <!-- Floating filter button (shown on mobile via JS) -->
  <button
    type="button"
    id="filter-mobile-btn"
    class="filter-mobile-btn"
    aria-label="Open filters"
    aria-expanded="false"
    aria-controls="filter-modal"
  >
    <Icon name="carbon:filter" class="icon-md" />
    <span id="active-filter-count" class="filter-badge is-hidden">0</span>
  </button>

  <!-- Filter Modal (populated via JS) -->
  <div id="filter-modal" class="filter-modal" role="dialog" aria-modal="true" aria-labelledby="filter-modal-title">
    <div class="filter-modal-backdrop"></div>
    <div class="filter-modal-content">
      <div class="filter-modal-header">
        <h2 id="filter-modal-title" class="filter-modal-title">Filters</h2>
        <button type="button" id="filter-modal-close" class="filter-modal-close" aria-label="Close filters">
          <Icon name="carbon:close" class="icon-md" />
        </button>
      </div>
      <div class="filter-modal-body">
        <!-- Filter content cloned here via JS -->
      </div>
      <div class="filter-modal-footer">
        <button id="modal-clear-filters" class="modal-clear-btn">Clear all</button>
        <button id="modal-apply-filters" class="modal-apply-btn">Apply</button>
      </div>
    </div>
  </div>

  <!-- Pass data to client via JSON script tags -->
  <script is:inline id="search-schema-data" type="application/json" set:html={searchSchemaJson} />
  <script is:inline id="search-index-path" type="application/json" set:html={JSON.stringify(searchIndexPath)} />
</Layout>

<script>
  import { create, load, search } from "@orama/orama"

  // Load shared constants from server-rendered JSON
  const searchSchema = JSON.parse(document.getElementById("search-schema-data")?.textContent ?? "{}")

  interface SearchParams {
    q: string
    categories: string[]
    topics: string[]
  }

  let db: Awaited<ReturnType<typeof create<typeof searchSchema>>> | null = null

  // Get search index path from server-rendered data
  const searchIndexPath = JSON.parse(
    document.getElementById("search-index-path")?.textContent ?? '"/search/index.json"',
  )

  // Load search index
  async function loadIndex() {
    if (db) return
    try {
      const response = await fetch(searchIndexPath)
      const data = await response.json()
      db = create({ schema: searchSchema })
      load(db, data)
    } catch (e) {
      console.error("Failed to load search index:", e)
    }
  }

  // Parse URL params
  function getUrlParams(): SearchParams {
    const params = new URLSearchParams(window.location.search)
    return {
      q: params.get("q") || "",
      categories: params.get("categories")?.split(",").filter(Boolean) || [],
      topics: params.get("topics")?.split(",").filter(Boolean) || [],
    }
  }

  // Update URL and trigger search via pushState
  function updateUrl(params: SearchParams) {
    const url = new URL(window.location.href)

    if (params.q) url.searchParams.set("q", params.q)
    else url.searchParams.delete("q")

    if (params.categories.length) url.searchParams.set("categories", params.categories.join(","))
    else url.searchParams.delete("categories")

    if (params.topics.length) url.searchParams.set("topics", params.topics.join(","))
    else url.searchParams.delete("topics")

    // Use pushState to enable back/forward navigation
    window.history.pushState({}, "", url.toString())
    // Dispatch popstate to trigger search
    window.dispatchEvent(new PopStateEvent("popstate"))
  }

  // Toggle a value in an array (add if not present, remove if present)
  function toggleArrayValue(arr: string[], value: string): string[] {
    const index = arr.indexOf(value)
    if (index === -1) {
      return [...arr, value]
    } else {
      return arr.filter((v) => v !== value)
    }
  }

  // Check if any filters are active
  function hasActiveFilters(params: SearchParams) {
    return params.q || params.categories.length || params.topics.length
  }

  // Sync UI with current URL params
  function syncUIWithParams(params: SearchParams) {
    const queryInput = document.getElementById("search-query") as HTMLInputElement
    const hintEl = document.getElementById("search-hint") as HTMLParagraphElement
    const clearBtn = document.getElementById("clear-filters") as HTMLButtonElement

    queryInput.value = params.q

    // Sync category checkboxes
    document.querySelectorAll<HTMLInputElement>('#filter-sidebar input[name="category"]').forEach((cb) => {
      cb.checked = params.categories.includes(cb.value)
    })

    // Sync topic checkboxes
    document.querySelectorAll<HTMLInputElement>('#filter-sidebar input[name="topic"]').forEach((cb) => {
      cb.checked = params.topics.includes(cb.value)
    })

    // Show/hide hint and clear button
    if (params.q) {
      hintEl.classList.add("is-hidden")
    } else {
      hintEl.classList.remove("is-hidden")
    }

    if (hasActiveFilters(params)) {
      clearBtn.classList.remove("is-hidden")
    } else {
      clearBtn.classList.add("is-hidden")
    }
  }

  // Execute search
  async function executeSearch(params: SearchParams) {
    await loadIndex()
    if (!db) {
      console.error("Search index not loaded")
      return
    }

    const resultsEl = document.getElementById("search-results") as HTMLUListElement
    const countEl = document.getElementById("result-count") as HTMLParagraphElement

    // Show placeholder if no search query and no filters
    if (!params.q && !params.categories.length && !params.topics.length) {
      resultsEl.innerHTML = `
        <li id="search-placeholder" class="content-item">
          <p class="text-muted">Enter a search term or select filters to find content.</p>
        </li>
      `
      countEl.classList.add("is-hidden")
      return
    }

    // Execute search (use empty term if only filtering)
    const results = await search(db, {
      term: params.q || "",
      limit: 100,
    })

    // Filter results
    let filteredHits = results.hits as any[]

    // Category filter (OR)
    if (params.categories.length > 0) {
      filteredHits = filteredHits.filter((hit) => {
        const category = hit.document.category || ""
        return params.categories.includes(category)
      })
    }

    // Topic filter (OR)
    if (params.topics.length > 0) {
      filteredHits = filteredHits.filter((hit) => {
        const topic = hit.document.topic || ""
        return params.topics.includes(topic)
      })
    }

    // Render results
    renderResults({ hits: filteredHits, count: filteredHits.length }, resultsEl, countEl)
  }

  // Render search results
  function renderResults(
    results: { hits: any[]; count: number },
    resultsEl: HTMLUListElement,
    countEl: HTMLParagraphElement,
  ) {
    if (results.count === 0) {
      resultsEl.innerHTML = `
        <li class="content-item">
          <p class="text-muted">No results found. Try different search terms or filters.</p>
        </li>
      `
      countEl.classList.add("is-hidden")
      return
    }

    countEl.textContent = `${results.count} result${results.count === 1 ? "" : "s"} found`
    countEl.classList.remove("is-hidden")

    resultsEl.innerHTML = results.hits
      .map((hit) => {
        const doc = hit.document
        const href = doc.href || ""
        const title = doc.title || "Untitled"
        const description = doc.description || ""
        const categoryId = doc.category || ""
        const categoryName = doc.categoryName || ""
        const topicId = doc.topic || ""
        const topicName = doc.topicName || ""
        const categoryHref = categoryId ? `/articles/${categoryId}` : ""
        const topicHref = categoryId && topicId ? `/articles/${categoryId}/${topicId}` : ""
        const minutesRead = doc.minutesRead || ""

        return `
          <li class="content-item cursor-pointer">
            <h3 class="content-item-title">
              <a href="${href}" class="content-item-link">${title}</a>
            </h3>
            <div class="frontmatter mb-4">
              <span class="inline-flex items-center gap-1">
                ${categoryName ? `<a href="${categoryHref}" class="hover:underline text-muted">${categoryName}</a>` : ""}
                ${topicName ? `<span class="text-muted">/</span><a href="${topicHref}" class="hover:underline text-muted">${topicName}</a>` : ""}
              </span>
              ${
                minutesRead
                  ? `<span class="inline-flex items-center gap-1">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 32 32"><path fill="currentColor" d="M16 30a14 14 0 1 1 14-14a14 14 0 0 1-14 14m0-26a12 12 0 1 0 12 12A12 12 0 0 0 16 4"/><path fill="currentColor" d="M20.59 22L15 16.41V7h2v8.58l5 5.01z"/></svg>
                <span>${minutesRead}</span>
              </span>`
                  : ""
              }
            </div>
            <p class="content-item-excerpt">${description}</p>
          </li>
        `
      })
      .join("")
  }

  // Update filter count badge
  function updateFilterCountBadge(params: SearchParams) {
    const countEl = document.getElementById("active-filter-count")
    if (!countEl) return

    const count = params.categories.length + params.topics.length
    if (count > 0) {
      countEl.textContent = String(count)
      countEl.classList.remove("is-hidden")
    } else {
      countEl.classList.add("is-hidden")
    }
  }

  // Handle URL change (the single source of truth for search)
  async function handleUrlChange() {
    const params = getUrlParams()
    syncUIWithParams(params)
    updateFilterCountBadge(params)
    await executeSearch(params)
  }

  // Filter modal functions
  function initFilterModal() {
    const mobileBtn = document.getElementById("filter-mobile-btn")
    const modal = document.getElementById("filter-modal")
    const modalBody = modal?.querySelector(".filter-modal-body")
    const closeBtn = document.getElementById("filter-modal-close")
    const backdrop = modal?.querySelector(".filter-modal-backdrop")
    const modalClearBtn = document.getElementById("modal-clear-filters")
    const modalApplyBtn = document.getElementById("modal-apply-filters")
    const filterSidebar = document.getElementById("filter-sidebar")
    const searchFilters = document.getElementById("search-filters")

    if (!mobileBtn || !modal || !modalBody || !searchFilters) return

    // Show mobile button (JS is enabled)
    mobileBtn.classList.add("is-visible")

    function openModal() {
      if (!modal || !modalBody || !searchFilters) return

      // Clone filter content into modal
      const filtersClone = searchFilters.cloneNode(true) as HTMLElement
      filtersClone.id = "modal-filters"

      // Update input names in cloned content to avoid conflicts
      filtersClone.querySelectorAll('input[name="category"]').forEach((input) => {
        input.setAttribute("name", "category-modal")
      })
      filtersClone.querySelectorAll('input[name="topic"]').forEach((input) => {
        input.setAttribute("name", "topic-modal")
      })

      modalBody.innerHTML = ""
      modalBody.appendChild(filtersClone)

      // Sync checkbox state with current params
      const params = getUrlParams()
      filtersClone.querySelectorAll<HTMLInputElement>('input[name="category-modal"]').forEach((cb) => {
        cb.checked = params.categories.includes(cb.value)
      })
      filtersClone.querySelectorAll<HTMLInputElement>('input[name="topic-modal"]').forEach((cb) => {
        cb.checked = params.topics.includes(cb.value)
      })

      // Add event listeners to modal category checkboxes
      filtersClone.querySelectorAll<HTMLInputElement>('input[name="category-modal"]').forEach((cb) => {
        cb.addEventListener("change", () => {
          const params = getUrlParams()
          params.categories = toggleArrayValue(params.categories, cb.value)
          // Sync sidebar checkbox
          const sidebarCb = filterSidebar?.querySelector<HTMLInputElement>(
            `input[name="category"][value="${cb.value}"]`,
          )
          if (sidebarCb) sidebarCb.checked = cb.checked
          updateUrl(params)
        })
      })

      // Add event listeners to modal topic checkboxes
      filtersClone.querySelectorAll<HTMLInputElement>('input[name="topic-modal"]').forEach((cb) => {
        cb.addEventListener("change", () => {
          const params = getUrlParams()
          params.topics = toggleArrayValue(params.topics, cb.value)
          // Sync sidebar checkbox
          const sidebarCb = filterSidebar?.querySelector<HTMLInputElement>(`input[name="topic"][value="${cb.value}"]`)
          if (sidebarCb) sidebarCb.checked = cb.checked
          updateUrl(params)
        })
      })

      modal.classList.add("is-open")
      mobileBtn?.setAttribute("aria-expanded", "true")
      document.body.style.overflow = "hidden"
      closeBtn?.focus()
    }

    function closeModal() {
      if (!modal || !modalBody) return
      modal.classList.remove("is-open")
      mobileBtn?.setAttribute("aria-expanded", "false")
      document.body.style.overflow = ""
      modalBody.innerHTML = ""
      mobileBtn?.focus()
    }

    // Event listeners
    mobileBtn.addEventListener("click", openModal)
    closeBtn?.addEventListener("click", closeModal)
    backdrop?.addEventListener("click", closeModal)
    modalApplyBtn?.addEventListener("click", closeModal)

    modalClearBtn?.addEventListener("click", () => {
      const params = getUrlParams()
      params.categories = []
      params.topics = []
      updateUrl(params)
      closeModal()
    })

    // Close on Escape
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && modal.classList.contains("is-open")) {
        closeModal()
      }
    })
  }

  // Initialize
  document.addEventListener("DOMContentLoaded", async () => {
    const queryInput = document.getElementById("search-query") as HTMLInputElement
    const clearBtn = document.getElementById("clear-filters") as HTMLButtonElement

    // Initialize filter modal
    initFilterModal()

    // Listen for URL changes (back/forward navigation and programmatic changes)
    window.addEventListener("popstate", handleUrlChange)

    // Initial sync and search based on current URL
    await handleUrlChange()

    // Query input: update URL on Enter
    queryInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        const params = getUrlParams()
        params.q = queryInput.value.trim()
        updateUrl(params)
      }
    })

    // Category filters: toggle value in URL
    document.querySelectorAll<HTMLInputElement>('#filter-sidebar input[name="category"]').forEach((cb) => {
      cb.addEventListener("change", () => {
        const params = getUrlParams()
        params.categories = toggleArrayValue(params.categories, cb.value)
        updateUrl(params)
      })
    })

    // Topic filters: toggle value in URL
    document.querySelectorAll<HTMLInputElement>('#filter-sidebar input[name="topic"]').forEach((cb) => {
      cb.addEventListener("change", () => {
        const params = getUrlParams()
        params.topics = toggleArrayValue(params.topics, cb.value)
        updateUrl(params)
      })
    })

    // Clear all filters: reset URL
    clearBtn?.addEventListener("click", () => {
      const emptyParams: SearchParams = { q: "", categories: [], topics: [] }
      updateUrl(emptyParams)
    })

    // Focus input on load
    queryInput.focus()
  })

  // Re-initialize on Astro page navigation
  document.addEventListener("astro:page-load", () => {
    initFilterModal()
  })
</script>

<style>
  .search-input:focus {
    border-color: var(--color-accent);
  }

  .filter-group {
    min-width: 200px;
  }

  /* Active filter chip styling */
  .filter-chip input:checked + .tag {
    background: var(--color-accent);
    color: var(--color-bg);
  }

  .filter-chip input:checked + .tag .text-muted-foreground {
    color: rgba(255, 255, 255, 0.8);
  }

  /* Floating filter button - hidden by default, shown via JS */
  .filter-mobile-btn {
    display: none;
    position: fixed;
    bottom: 1.5rem;
    right: 1.5rem;
    z-index: 40;
    padding: 0.875rem;
    background-color: var(--color-accent);
    color: white;
    border: none;
    border-radius: 9999px;
    box-shadow:
      0 4px 6px -1px rgb(0 0 0 / 0.1),
      0 2px 4px -2px rgb(0 0 0 / 0.1);
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .filter-mobile-btn:hover {
    transform: scale(1.05);
  }

  .filter-mobile-btn:focus {
    outline: 2px solid var(--color-accent);
    outline-offset: 2px;
  }

  /* Show button only when sidebar is hidden (JS enabled) */
  .filter-mobile-btn.is-visible {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  @media (min-width: 1200px) {
    .filter-mobile-btn.is-visible {
      display: none;
    }
  }

  /* Filter badge on floating button */
  .filter-badge {
    position: absolute;
    top: -0.25rem;
    right: -0.25rem;
    min-width: 1.25rem;
    height: 1.25rem;
    padding: 0 0.25rem;
    font-size: 0.75rem;
    font-weight: 600;
    line-height: 1.25rem;
    text-align: center;
    background-color: var(--color-text);
    color: var(--color-bg);
    border-radius: 9999px;
  }

  /* Filter modal styles */
  .filter-modal {
    display: none;
    position: fixed;
    inset: 0;
    z-index: 50;
  }

  .filter-modal.is-open {
    display: flex;
    align-items: flex-end;
    justify-content: center;
  }

  .filter-modal-backdrop {
    position: absolute;
    inset: 0;
    background-color: rgb(0 0 0 / 0.5);
  }

  .filter-modal-content {
    position: relative;
    width: 100%;
    max-width: 28rem;
    max-height: 70vh;
    margin: 0 1rem 1rem;
    background-color: var(--color-bg);
    border-radius: 1rem;
    box-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.25);
    display: flex;
    flex-direction: column;
    animation: filterSlideUp 0.2s ease-out;
  }

  @keyframes filterSlideUp {
    from {
      transform: translateY(1rem);
      opacity: 0;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }

  .filter-modal-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 1rem 1.25rem;
    border-bottom: 1px solid var(--color-border);
  }

  .filter-modal-close {
    padding: 0.5rem;
    border: none;
    background: transparent;
    color: var(--color-text-muted);
    border-radius: 0.5rem;
    cursor: pointer;
    transition: color 0.2s;
  }

  .filter-modal-close:hover {
    color: var(--color-text);
  }

  .filter-modal-close:focus {
    outline: 2px solid var(--color-accent);
    outline-offset: 2px;
  }

  .filter-modal-body {
    padding: 1rem 1.25rem;
    overflow-y: auto;
    flex: 1;
  }

  .filter-modal-footer {
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 1rem 1.25rem;
    border-top: 1px solid var(--color-border);
  }
</style>
