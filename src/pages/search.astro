---
import Layout from "@/layout/layout.astro"
import { getSearchFacets } from "@/utils/search.utils"
import { SEARCH_SCHEMA } from "@/utils/search.types"
import { CONTENT_TYPE_LABELS } from "@constants/site"
import { Icon } from "astro-icon/components"
import { getFilePath } from "@/utils/link.utils"

// Get facet options at build time (now with counts, sorted by count)
const { categories, tags } = await getSearchFacets()

// Top 10 tags for initial display (configurable limit)
const TOP_TAGS_LIMIT = 10
const topTags = tags.slice(0, TOP_TAGS_LIMIT)

// Serialize data for client-side script
const allTagsJson = JSON.stringify(tags)
const searchSchemaJson = JSON.stringify(SEARCH_SCHEMA)
const contentTypeLabelsJson = JSON.stringify(CONTENT_TYPE_LABELS)
const searchIndexPath = getFilePath("search/index.json")
---

<Layout title="Search" description="Search for posts on Sujeet's blog" crumbs={null} pageType="default" layout="3col">
  <!-- Left sidebar: Filter panel -->
  <div slot="sidebar-left" id="filter-sidebar" class="filter-sidebar">
    <!-- Sort Control -->
    <div class="sort-control">
      <label for="sort-select" class="sort-label">Sort by:</label>
      <select id="sort-select" class="sort-select">
        <option value="relevance">Relevance</option>
        <option value="date">Newest first</option>
      </select>
    </div>

    <!-- Faceted Filters -->
    <div id="search-filters" class="search-filters">
      <!-- Categories (OR logic) -->
      {
        categories.length > 0 && (
          <div class="filter-group">
            <h3 class="filter-group-title">Categories</h3>
            <div class="filter-group-list" id="category-filters">
              {categories.map((cat) => (
                <label class="filter-chip">
                  <input type="checkbox" name="category" value={cat.id} class="filter-chip-input peer" />
                  <span class="tag peer-checked:badge-accent">
                    {cat.name} <span class="text-muted">({cat.count})</span>
                  </span>
                </label>
              ))}
            </div>
          </div>
        )
      }

      <!-- Tags with typeahead (AND logic) -->
      {
        tags.length > 0 && (
          <div class="filter-group">
            <h3 class="filter-group-title">Tags</h3>
            <!-- Tag search input -->
            <div class="tag-typeahead-wrapper">
              <input
                type="text"
                id="tag-search"
                placeholder="Search tags..."
                class="tag-search-input"
                autocomplete="off"
              />
              <div id="tag-suggestions" class="tag-suggestions is-hidden" />
            </div>
            <!-- Selected tags (shown when selected from typeahead) -->
            <div id="selected-tags" class="selected-tags" />
            <!-- Top 10 tags -->
            <div class="filter-group-list" id="top-tags">
              {topTags.map((tag) => (
                <label class="filter-chip" data-tag-id={tag.id}>
                  <input type="checkbox" name="tag" value={tag.id} class="filter-chip-input peer" />
                  <span class="tag peer-checked:badge-accent">
                    {tag.name} <span class="text-muted">({tag.count})</span>
                  </span>
                </label>
              ))}
            </div>
          </div>
        )
      }
    </div>

    <!-- Clear filters button -->
    <button id="clear-filters" class="clear-filters-btn is-hidden">
      Clear all filters
    </button>
  </div>

  <!-- Main content: Search results -->
  <div class="search-page">
    <!-- Search Input -->
    <div class="search-input-wrapper">
      <input
        type="text"
        id="search-query"
        placeholder="Search..."
        class="search-input"
        autocomplete="off"
      />
      <p id="search-hint" class="search-hint">Press Enter to search</p>
    </div>

    <!-- Mobile sort control (shown when sidebar is hidden) -->
    <div id="mobile-sort-control" class="sort-control-mobile">
      <label for="sort-select-mobile" class="sort-label">Sort by:</label>
      <select id="sort-select-mobile" class="sort-select">
        <option value="relevance">Relevance</option>
        <option value="date">Newest first</option>
      </select>
    </div>

    <!-- Result count -->
    <p id="result-count" class="result-count is-hidden"></p>

    <!-- Results -->
    <ul id="search-results" class="content-list">
      <li id="search-placeholder" class="content-item">
        <p class="text-muted">Enter a search term or select filters to find content.</p>
      </li>
    </ul>
  </div>

  <!-- Floating filter button (shown on mobile via JS) -->
  <button
    type="button"
    id="filter-mobile-btn"
    class="filter-mobile-btn"
    aria-label="Open filters"
    aria-expanded="false"
    aria-controls="filter-modal"
  >
    <Icon name="carbon:filter" class="icon-md" />
    <span id="active-filter-count" class="filter-badge is-hidden">0</span>
  </button>

  <!-- Filter Modal (populated via JS) -->
  <div id="filter-modal" class="filter-modal" role="dialog" aria-modal="true" aria-labelledby="filter-modal-title">
    <div class="filter-modal-backdrop"></div>
    <div class="filter-modal-content">
      <div class="filter-modal-header">
        <h2 id="filter-modal-title" class="filter-modal-title">Filters</h2>
        <button type="button" id="filter-modal-close" class="filter-modal-close" aria-label="Close filters">
          <Icon name="carbon:close" class="icon-md" />
        </button>
      </div>
      <div class="filter-modal-body">
        <!-- Filter content cloned here via JS -->
      </div>
      <div class="filter-modal-footer">
        <button id="modal-clear-filters" class="modal-clear-btn">Clear all</button>
        <button id="modal-apply-filters" class="modal-apply-btn">Apply</button>
      </div>
    </div>
  </div>

  <!-- Pass data to client via JSON script tags -->
  <script id="all-tags-data" type="application/json" set:html={allTagsJson} />
  <script id="search-schema-data" type="application/json" set:html={searchSchemaJson} />
  <script id="content-type-labels-data" type="application/json" set:html={contentTypeLabelsJson} />
  <script id="search-index-path" type="application/json" set:html={JSON.stringify(searchIndexPath)} />
</Layout>

<script>
  import { create, load, search } from "@orama/orama"

  // Load shared constants from server-rendered JSON
  const CONTENT_TYPE_LABELS: Record<string, string> = JSON.parse(
    document.getElementById("content-type-labels-data")?.textContent ?? "{}"
  )
  const searchSchema = JSON.parse(
    document.getElementById("search-schema-data")?.textContent ?? "{}"
  )

  interface SearchParams {
    q: string
    sortBy: "relevance" | "date"
    categories: string[]
    tags: string[]
  }

  interface TagItem {
    id: string
    name: string
    count: number
  }

  let db: Awaited<ReturnType<typeof create<typeof searchSchema>>> | null = null
  let allTags: TagItem[] = []

  // Load all tags from embedded JSON
  function loadAllTags() {
    const script = document.getElementById("all-tags-data")
    if (script) {
      try {
        allTags = JSON.parse(script.textContent || "[]")
      } catch (e) {
        console.error("Failed to parse tags data:", e)
      }
    }
  }

  // Get search index path from server-rendered data
  const searchIndexPath = JSON.parse(
    document.getElementById("search-index-path")?.textContent ?? '"/search/index.json"'
  )

  // Load search index
  async function loadIndex() {
    if (db) return
    try {
      const response = await fetch(searchIndexPath)
      const data = await response.json()
      db = await create({ schema: searchSchema })
      await load(db, data)
    } catch (e) {
      console.error("Failed to load search index:", e)
    }
  }

  // Parse URL params
  function getUrlParams(): SearchParams {
    const params = new URLSearchParams(window.location.search)
    return {
      q: params.get("q") || "",
      sortBy: (params.get("sortBy") || "relevance") as "relevance" | "date",
      categories: params.get("categories")?.split(",").filter(Boolean) || [],
      tags: params.get("tags")?.split(",").filter(Boolean) || [],
    }
  }

  // Update URL and trigger search via pushState
  function updateUrl(params: SearchParams) {
    const url = new URL(window.location.href)

    if (params.q) url.searchParams.set("q", params.q)
    else url.searchParams.delete("q")

    if (params.sortBy !== "relevance") url.searchParams.set("sortBy", params.sortBy)
    else url.searchParams.delete("sortBy")

    if (params.categories.length) url.searchParams.set("categories", params.categories.join(","))
    else url.searchParams.delete("categories")

    if (params.tags.length) url.searchParams.set("tags", params.tags.join(","))
    else url.searchParams.delete("tags")

    // Use pushState to enable back/forward navigation
    window.history.pushState({}, "", url.toString())
    // Dispatch popstate to trigger search
    window.dispatchEvent(new PopStateEvent("popstate"))
  }

  // Toggle a value in an array (add if not present, remove if present)
  function toggleArrayValue(arr: string[], value: string): string[] {
    const index = arr.indexOf(value)
    if (index === -1) {
      return [...arr, value]
    } else {
      return arr.filter((v) => v !== value)
    }
  }

  // Check if any filters are active
  function hasActiveFilters(params: SearchParams) {
    return params.q || params.categories.length || params.tags.length
  }

  // Update selected tags display (for tags selected via typeahead that aren't in top 10)
  function updateSelectedTagsDisplay(params: SearchParams) {
    const container = document.getElementById("selected-tags")
    if (!container) return

    // Find tags that are selected but not in top 10
    const topTagIds = new Set(
      Array.from(document.querySelectorAll(`#top-tags [data-tag-id]`)).map((el) => el.getAttribute("data-tag-id")),
    )

    const extraSelectedTags = params.tags
      .filter((tagId) => !topTagIds.has(tagId))
      .map((tagId) => allTags.find((t) => t.id === tagId))
      .filter(Boolean) as TagItem[]

    container.innerHTML = extraSelectedTags
      .map(
        (tag) => `
      <label class="filter-chip cursor-pointer" data-extra-tag="${tag.id}">
        <input type="checkbox" name="tag" value="${tag.id}" class="peer sr-only" checked />
        <span class="tag peer-checked:badge-accent">${tag.name} <span class="text-muted-foreground">(${tag.count})</span></span>
      </label>
    `,
      )
      .join("")

    // Add event listeners to extra tags
    container.querySelectorAll("input").forEach((cb) => {
      cb.addEventListener("change", () => {
        const params = getUrlParams()
        params.tags = toggleArrayValue(params.tags, cb.value)
        updateUrl(params)
      })
    })
  }

  // Sync UI with current URL params
  function syncUIWithParams(params: SearchParams) {
    const queryInput = document.getElementById("search-query") as HTMLInputElement
    const sortSelect = document.getElementById("sort-select") as HTMLSelectElement
    const sortSelectMobile = document.getElementById("sort-select-mobile") as HTMLSelectElement
    const hintEl = document.getElementById("search-hint") as HTMLParagraphElement
    const clearBtn = document.getElementById("clear-filters") as HTMLButtonElement

    queryInput.value = params.q
    if (sortSelect) sortSelect.value = params.sortBy
    if (sortSelectMobile) sortSelectMobile.value = params.sortBy

    // Sync filter checkboxes
    document.querySelectorAll<HTMLInputElement>('#filter-sidebar input[name="category"]').forEach((cb) => {
      cb.checked = params.categories.includes(cb.value)
    })
    document.querySelectorAll<HTMLInputElement>('#filter-sidebar input[name="tag"]').forEach((cb) => {
      cb.checked = params.tags.includes(cb.value)
    })

    // Update selected tags display for typeahead selections
    updateSelectedTagsDisplay(params)

    // Show/hide hint and clear button
    if (params.q) {
      hintEl.classList.add("is-hidden")
    } else {
      hintEl.classList.remove("is-hidden")
    }

    if (hasActiveFilters(params)) {
      clearBtn.classList.remove("is-hidden")
    } else {
      clearBtn.classList.add("is-hidden")
    }
  }

  // Setup typeahead for tag search
  function setupTagTypeahead(inputId: string, suggestionsId: string) {
    const input = document.getElementById(inputId) as HTMLInputElement
    const suggestions = document.getElementById(suggestionsId) as HTMLDivElement
    if (!input || !suggestions) return

    let selectedIndex = -1

    function showSuggestions(query: string) {
      const params = getUrlParams()
      const lowerQuery = query.toLowerCase()
      const filtered = allTags
        .filter((tag) => tag.name.toLowerCase().includes(lowerQuery) && !params.tags.includes(tag.id))
        .slice(0, 8)

      if (filtered.length === 0 || !query) {
        suggestions.classList.add("is-hidden")
        return
      }

      suggestions.innerHTML = filtered
        .map(
          (tag, i) => `
        <div class="tag-suggestion ${i === selectedIndex ? "selected" : ""}" data-tag-id="${tag.id}" data-index="${i}">
          <span>${tag.name}</span>
          <span class="text-muted text-xs">(${tag.count})</span>
        </div>
      `,
        )
        .join("")

      suggestions.classList.remove("is-hidden")

      // Add click handlers
      suggestions.querySelectorAll(".tag-suggestion").forEach((el) => {
        el.addEventListener("click", () => {
          const tagId = el.getAttribute("data-tag-id")
          if (tagId) {
            selectTag(tagId)
          }
        })
      })
    }

    function selectTag(tagId: string) {
      const params = getUrlParams()
      if (!params.tags.includes(tagId)) {
        params.tags = [...params.tags, tagId]
        updateUrl(params)
      }
      input.value = ""
      suggestions.classList.add("is-hidden")
      selectedIndex = -1
    }

    input.addEventListener("input", () => {
      selectedIndex = -1
      showSuggestions(input.value)
    })

    input.addEventListener("keydown", (e) => {
      const items = suggestions.querySelectorAll(".tag-suggestion")

      if (e.key === "ArrowDown") {
        e.preventDefault()
        selectedIndex = Math.min(selectedIndex + 1, items.length - 1)
        showSuggestions(input.value)
      } else if (e.key === "ArrowUp") {
        e.preventDefault()
        selectedIndex = Math.max(selectedIndex - 1, 0)
        showSuggestions(input.value)
      } else if (e.key === "Enter") {
        e.preventDefault()
        const selectedItem = selectedIndex >= 0 ? items[selectedIndex] : undefined
        if (selectedItem) {
          const tagId = selectedItem.getAttribute("data-tag-id")
          if (tagId) selectTag(tagId)
        }
      } else if (e.key === "Escape") {
        suggestions.classList.add("is-hidden")
        selectedIndex = -1
      }
    })

    input.addEventListener("blur", () => {
      // Delay to allow click on suggestion
      setTimeout(() => {
        suggestions.classList.add("is-hidden")
        selectedIndex = -1
      }, 200)
    })

    input.addEventListener("focus", () => {
      if (input.value) {
        showSuggestions(input.value)
      }
    })
  }

  // Execute search
  async function executeSearch(params: SearchParams) {
    await loadIndex()
    if (!db) {
      console.error("Search index not loaded")
      return
    }

    const resultsEl = document.getElementById("search-results") as HTMLUListElement
    const countEl = document.getElementById("result-count") as HTMLParagraphElement

    // Show placeholder if no search query and no filters
    if (!params.q && !params.categories.length && !params.tags.length) {
      resultsEl.innerHTML = `
        <li id="search-placeholder" class="content-item">
          <p class="text-muted">Enter a search term or select filters to find content.</p>
        </li>
      `
      countEl.classList.add("is-hidden")
      return
    }

    // Execute search (use empty term if only filtering)
    const results = await search(db, {
      term: params.q || "",
      limit: 100,
    })

    // Filter results using proper schema fields
    let filteredHits = results.hits as any[]

    // Category filter (OR) - uses category field directly
    if (params.categories.length > 0) {
      filteredHits = filteredHits.filter((hit) => {
        const category = hit.document.category || ""
        return params.categories.includes(category)
      })
    }

    // Tag filter (AND) - uses tags array directly
    if (params.tags.length > 0) {
      filteredHits = filteredHits.filter((hit) => {
        const docTags: string[] = hit.document.tags || []
        return params.tags.every((tag) => docTags.includes(tag))
      })
    }

    // Sort by date if requested (using publishedOn timestamp)
    if (params.sortBy === "date") {
      filteredHits.sort((a, b) => {
        const dateA = a.document.publishedOn || 0
        const dateB = b.document.publishedOn || 0
        return dateB - dateA
      })
    }

    // Render results
    renderResults({ hits: filteredHits, count: filteredHits.length }, resultsEl, countEl)
  }

  // Format date from timestamp
  function formatDate(timestamp: number) {
    if (!timestamp) return ""
    const date = new Date(timestamp)
    return date.toLocaleDateString("en-us", {
      year: "numeric",
      month: "short",
      day: "numeric",
    })
  }

  // Render search results
  function renderResults(
    results: { hits: any[]; count: number },
    resultsEl: HTMLUListElement,
    countEl: HTMLParagraphElement,
  ) {
    if (results.count === 0) {
      resultsEl.innerHTML = `
        <li class="content-item">
          <p class="text-muted">No results found. Try different search terms or filters.</p>
        </li>
      `
      countEl.classList.add("is-hidden")
      return
    }

    countEl.textContent = `${results.count} result${results.count === 1 ? "" : "s"} found`
    countEl.classList.remove("is-hidden")

    resultsEl.innerHTML = results.hits
      .map((hit) => {
        const doc = hit.document
        const href = doc.href || ""
        const title = doc.title || "Untitled"
        const description = doc.description || ""
        const type = doc.type || "writing"
        const typeLabel = CONTENT_TYPE_LABELS[type] || type
        const categoryId = doc.category || ""
        const categoryName = doc.categoryName || ""
        const categoryHref = categoryId ? `/${type}/${categoryId}` : ""
        const publishedOn = doc.publishedOn || 0
        const formattedDate = formatDate(publishedOn)
        const minutesRead = doc.minutesRead || ""

        return `
          <li class="content-item cursor-pointer">
            <h3 class="content-item-title">
              <a href="${href}" class="content-item-link">${title}</a>
            </h3>
            <div class="frontmatter mb-4">
              <span class="inline-flex items-center gap-1">
                <span class="text-muted">${typeLabel}</span>
                ${categoryName ? `<span class="text-muted">/</span><a href="${categoryHref}" class="hover:underline text-muted">${categoryName}</a>` : ""}
              </span>
              ${
                minutesRead
                  ? `<span class="inline-flex items-center gap-1">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 32 32"><path fill="currentColor" d="M16 30a14 14 0 1 1 14-14a14 14 0 0 1-14 14m0-26a12 12 0 1 0 12 12A12 12 0 0 0 16 4"/><path fill="currentColor" d="M20.59 22L15 16.41V7h2v8.58l5 5.01z"/></svg>
                <span>${minutesRead}</span>
              </span>`
                  : ""
              }
              ${
                formattedDate
                  ? `<span class="inline-flex items-center gap-1">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 32 32"><path fill="currentColor" d="M26 4h-4V2h-2v2h-8V2h-2v2H6c-1.1 0-2 .9-2 2v20c0 1.1.9 2 2 2h20c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2m0 22H6V12h20zm0-16H6V6h4v2h2V6h8v2h2V6h4z"/></svg>
                <time>${formattedDate}</time>
              </span>`
                  : ""
              }
            </div>
            <p class="content-item-excerpt">${description}</p>
          </li>
        `
      })
      .join("")
  }

  // Update filter count badge
  function updateFilterCountBadge(params: SearchParams) {
    const countEl = document.getElementById("active-filter-count")
    if (!countEl) return

    const count = params.categories.length + params.tags.length
    if (count > 0) {
      countEl.textContent = String(count)
      countEl.classList.remove("is-hidden")
    } else {
      countEl.classList.add("is-hidden")
    }
  }

  // Handle URL change (the single source of truth for search)
  async function handleUrlChange() {
    const params = getUrlParams()
    syncUIWithParams(params)
    updateFilterCountBadge(params)
    await executeSearch(params)
  }

  // Filter modal functions
  function initFilterModal() {
    const mobileBtn = document.getElementById("filter-mobile-btn")
    const modal = document.getElementById("filter-modal")
    const modalBody = modal?.querySelector(".filter-modal-body")
    const closeBtn = document.getElementById("filter-modal-close")
    const backdrop = modal?.querySelector(".filter-modal-backdrop")
    const modalClearBtn = document.getElementById("modal-clear-filters")
    const modalApplyBtn = document.getElementById("modal-apply-filters")
    const filterSidebar = document.getElementById("filter-sidebar")
    const searchFilters = document.getElementById("search-filters")

    if (!mobileBtn || !modal || !modalBody || !searchFilters) return

    // Show mobile button (JS is enabled)
    mobileBtn.classList.add("is-visible")

    function openModal() {
      if (!modal || !modalBody || !searchFilters) return

      // Clone filter content into modal (excluding sort control)
      const filtersClone = searchFilters.cloneNode(true) as HTMLElement
      filtersClone.id = "modal-filters"

      // Update input names in cloned content to avoid conflicts
      filtersClone.querySelectorAll('input[name="category"]').forEach((input) => {
        input.setAttribute("name", "category-modal")
      })
      filtersClone.querySelectorAll('input[name="tag"]').forEach((input) => {
        input.setAttribute("name", "tag-modal")
      })

      // Update IDs to avoid conflicts
      const tagSearch = filtersClone.querySelector("#tag-search")
      if (tagSearch) tagSearch.id = "tag-search-modal"
      const tagSuggestions = filtersClone.querySelector("#tag-suggestions")
      if (tagSuggestions) tagSuggestions.id = "tag-suggestions-modal"
      const selectedTags = filtersClone.querySelector("#selected-tags")
      if (selectedTags) selectedTags.id = "selected-tags-modal"
      const topTags = filtersClone.querySelector("#top-tags")
      if (topTags) topTags.id = "top-tags-modal"

      modalBody.innerHTML = ""
      modalBody.appendChild(filtersClone)

      // Sync checkbox state with current params
      const params = getUrlParams()
      filtersClone.querySelectorAll<HTMLInputElement>('input[name="category-modal"]').forEach((cb) => {
        cb.checked = params.categories.includes(cb.value)
      })
      filtersClone.querySelectorAll<HTMLInputElement>('input[name="tag-modal"]').forEach((cb) => {
        cb.checked = params.tags.includes(cb.value)
      })

      // Add event listeners to modal checkboxes
      filtersClone.querySelectorAll<HTMLInputElement>('input[name="category-modal"]').forEach((cb) => {
        cb.addEventListener("change", () => {
          const params = getUrlParams()
          params.categories = toggleArrayValue(params.categories, cb.value)
          // Sync sidebar checkbox
          const sidebarCb = filterSidebar?.querySelector<HTMLInputElement>(`input[name="category"][value="${cb.value}"]`)
          if (sidebarCb) sidebarCb.checked = cb.checked
          updateUrl(params)
        })
      })

      filtersClone.querySelectorAll<HTMLInputElement>('input[name="tag-modal"]').forEach((cb) => {
        cb.addEventListener("change", () => {
          const params = getUrlParams()
          params.tags = toggleArrayValue(params.tags, cb.value)
          // Sync sidebar checkbox
          const sidebarCb = filterSidebar?.querySelector<HTMLInputElement>(`input[name="tag"][value="${cb.value}"]`)
          if (sidebarCb) sidebarCb.checked = cb.checked
          updateUrl(params)
        })
      })

      // Setup typeahead for modal
      setupTagTypeahead("tag-search-modal", "tag-suggestions-modal")

      modal.classList.add("is-open")
      mobileBtn.setAttribute("aria-expanded", "true")
      document.body.style.overflow = "hidden"
      closeBtn?.focus()
    }

    function closeModal() {
      if (!modal || !modalBody) return
      modal.classList.remove("is-open")
      mobileBtn.setAttribute("aria-expanded", "false")
      document.body.style.overflow = ""
      modalBody.innerHTML = ""
      mobileBtn.focus()
    }

    // Event listeners
    mobileBtn.addEventListener("click", openModal)
    closeBtn?.addEventListener("click", closeModal)
    backdrop?.addEventListener("click", closeModal)
    modalApplyBtn?.addEventListener("click", closeModal)

    modalClearBtn?.addEventListener("click", () => {
      const params = getUrlParams()
      params.categories = []
      params.tags = []
      updateUrl(params)
      closeModal()
    })

    // Close on Escape
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && modal.classList.contains("is-open")) {
        closeModal()
      }
    })
  }

  // Initialize
  document.addEventListener("DOMContentLoaded", async () => {
    // Load all tags data
    loadAllTags()

    const queryInput = document.getElementById("search-query") as HTMLInputElement
    const sortSelect = document.getElementById("sort-select") as HTMLSelectElement
    const sortSelectMobile = document.getElementById("sort-select-mobile") as HTMLSelectElement
    const clearBtn = document.getElementById("clear-filters") as HTMLButtonElement

    // Setup typeahead for sidebar
    setupTagTypeahead("tag-search", "tag-suggestions")

    // Initialize filter modal
    initFilterModal()

    // Listen for URL changes (back/forward navigation and programmatic changes)
    window.addEventListener("popstate", handleUrlChange)

    // Initial sync and search based on current URL
    await handleUrlChange()

    // Query input: update URL on Enter
    queryInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        const params = getUrlParams()
        params.q = queryInput.value.trim()
        updateUrl(params)
      }
    })

    // Sort select: update URL on change (desktop)
    sortSelect?.addEventListener("change", () => {
      const params = getUrlParams()
      params.sortBy = sortSelect.value as "relevance" | "date"
      if (sortSelectMobile) sortSelectMobile.value = sortSelect.value
      updateUrl(params)
    })

    // Sort select: update URL on change (mobile)
    sortSelectMobile?.addEventListener("change", () => {
      const params = getUrlParams()
      params.sortBy = sortSelectMobile.value as "relevance" | "date"
      if (sortSelect) sortSelect.value = sortSelectMobile.value
      updateUrl(params)
    })

    // Category filters: toggle value in URL
    document.querySelectorAll<HTMLInputElement>('#filter-sidebar input[name="category"]').forEach((cb) => {
      cb.addEventListener("change", () => {
        const params = getUrlParams()
        params.categories = toggleArrayValue(params.categories, cb.value)
        updateUrl(params)
      })
    })

    // Tag filters: toggle value in URL
    document.querySelectorAll<HTMLInputElement>('#filter-sidebar input[name="tag"]').forEach((cb) => {
      cb.addEventListener("change", () => {
        const params = getUrlParams()
        params.tags = toggleArrayValue(params.tags, cb.value)
        updateUrl(params)
      })
    })

    // Clear all filters: reset URL
    clearBtn?.addEventListener("click", () => {
      const emptyParams: SearchParams = { q: "", sortBy: "relevance", categories: [], tags: [] }
      updateUrl(emptyParams)
    })

    // Focus input on load
    queryInput.focus()
  })

  // Re-initialize on Astro page navigation
  document.addEventListener("astro:page-load", () => {
    loadAllTags()
    initFilterModal()
  })
</script>

<style>
  .search-input:focus {
    border-color: var(--color-accent);
  }

  /* Mobile sort control - hidden on desktop when sidebar is visible */
  .sort-control-mobile {
    display: flex;
  }

  @media (min-width: 1200px) {
    .sort-control-mobile {
      display: none;
    }
  }

  .filter-group {
    min-width: 200px;
  }

  /* Active filter chip styling */
  .filter-chip input:checked + .tag {
    background: var(--color-accent);
    color: var(--color-bg);
  }

  .filter-chip input:checked + .tag .text-muted-foreground {
    color: rgba(255, 255, 255, 0.8);
  }

  /* Floating filter button - hidden by default, shown via JS */
  .filter-mobile-btn {
    display: none;
    position: fixed;
    bottom: 1.5rem;
    right: 1.5rem;
    z-index: 40;
    padding: 0.875rem;
    background-color: var(--color-accent);
    color: white;
    border: none;
    border-radius: 9999px;
    box-shadow:
      0 4px 6px -1px rgb(0 0 0 / 0.1),
      0 2px 4px -2px rgb(0 0 0 / 0.1);
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .filter-mobile-btn:hover {
    transform: scale(1.05);
  }

  .filter-mobile-btn:focus {
    outline: 2px solid var(--color-accent);
    outline-offset: 2px;
  }

  /* Show button only when sidebar is hidden (JS enabled) */
  .filter-mobile-btn.visible {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  @media (min-width: 1200px) {
    .filter-mobile-btn.visible {
      display: none;
    }
  }

  /* Filter badge on floating button */
  .filter-badge {
    position: absolute;
    top: -0.25rem;
    right: -0.25rem;
    min-width: 1.25rem;
    height: 1.25rem;
    padding: 0 0.25rem;
    font-size: 0.75rem;
    font-weight: 600;
    line-height: 1.25rem;
    text-align: center;
    background-color: var(--color-text);
    color: var(--color-bg);
    border-radius: 9999px;
  }

  /* Filter modal styles */
  .filter-modal {
    display: none;
    position: fixed;
    inset: 0;
    z-index: 50;
  }

  .filter-modal.open {
    display: flex;
    align-items: flex-end;
    justify-content: center;
  }

  .filter-modal-backdrop {
    position: absolute;
    inset: 0;
    background-color: rgb(0 0 0 / 0.5);
  }

  .filter-modal-content {
    position: relative;
    width: 100%;
    max-width: 28rem;
    max-height: 70vh;
    margin: 0 1rem 1rem;
    background-color: var(--color-bg);
    border-radius: 1rem;
    box-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.25);
    display: flex;
    flex-direction: column;
    animation: filterSlideUp 0.2s ease-out;
  }

  @keyframes filterSlideUp {
    from {
      transform: translateY(1rem);
      opacity: 0;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }

  .filter-modal-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 1rem 1.25rem;
    border-bottom: 1px solid var(--color-border);
  }

  .filter-modal-close {
    padding: 0.5rem;
    border: none;
    background: transparent;
    color: var(--color-text-muted);
    border-radius: 0.5rem;
    cursor: pointer;
    transition: color 0.2s;
  }

  .filter-modal-close:hover {
    color: var(--color-text);
  }

  .filter-modal-close:focus {
    outline: 2px solid var(--color-accent);
    outline-offset: 2px;
  }

  .filter-modal-body {
    padding: 1rem 1.25rem;
    overflow-y: auto;
    flex: 1;
  }

  .filter-modal-footer {
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 1rem 1.25rem;
    border-top: 1px solid var(--color-border);
  }

  /* Tag search input */
  .tag-search-input:focus {
    border-color: var(--color-accent);
    outline: none;
  }

  /* Tag suggestions dropdown */
  .tag-suggestions {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background: var(--color-bg);
    border: 1px solid var(--color-border);
    border-radius: 0.375rem;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    z-index: 50;
    max-height: 200px;
    overflow-y: auto;
  }

  .tag-suggestion {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.5rem 0.75rem;
    cursor: pointer;
    transition: background-color 150ms ease;
  }

  .tag-suggestion:hover,
  .tag-suggestion.selected {
    background: var(--color-bg-alt);
  }
</style>
